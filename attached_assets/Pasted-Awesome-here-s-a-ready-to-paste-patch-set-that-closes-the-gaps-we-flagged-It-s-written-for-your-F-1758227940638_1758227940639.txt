Awesome — here’s a ready-to-paste patch set that closes the gaps we flagged. It’s written for your FastAPI backend (as you have in your repo). This gives you:

Returning-merchant recognition (+ reuse open deal)

“Ask only what’s missing/expired” intake loop

Bank statements → metrics snapshot on the deal

Offers tied to deal_id with guardrails

Consent + Cherry SMS endpoints (send + webhook)

Event rows that include tenant_id and deal_id

Simple Idempotency-Key guard

If any filenames differ in your project, just drop the code into the closest matching files and adjust imports.

0) DB changes (minimal migration)

If you use Alembic, create a revision and include the following ops. If not, run the raw SQL once.

Alembic (preferred)
# alembic/versions/uwizard_min_automation.py
from alembic import op
import sqlalchemy as sa

revision = "uwizard_min_automation"
down_revision = "<PUT_PREVIOUS_REVISION_HERE>"
branch_labels = None
depends_on = None

def upgrade():
    with op.batch_alter_table("offers") as b:
        b.add_column(sa.Column("deal_id", sa.String(), nullable=True))
    with op.batch_alter_table("events") as b:
        b.add_column(sa.Column("tenant_id", sa.String(), nullable=True))
        b.add_column(sa.Column("deal_id", sa.String(), nullable=True))
    op.create_table(
        "consents",
        sa.Column("id", sa.String(), primary_key=True),
        sa.Column("merchant_id", sa.String(), nullable=False),
        sa.Column("channel", sa.String(), nullable=False),  # "sms" | "email"
        sa.Column("status", sa.String(), nullable=False),   # "opt_in" | "opt_out"
        sa.Column("timestamp", sa.DateTime(), server_default=sa.func.now(), nullable=False),
    )
    # Optional: enforce unique consent per (merchant, channel)
    op.create_unique_constraint("uq_consents_merchant_channel", "consents", ["merchant_id","channel"])

def downgrade():
    op.drop_constraint("uq_consents_merchant_channel","consents", type_="unique")
    op.drop_table("consents")
    with op.batch_alter_table("events") as b:
        b.drop_column("deal_id")
        b.drop_column("tenant_id")
    with op.batch_alter_table("offers") as b:
        b.drop_column("deal_id")

Raw SQL (fallback)
ALTER TABLE offers ADD COLUMN deal_id TEXT;
ALTER TABLE events ADD COLUMN tenant_id TEXT;
ALTER TABLE events ADD COLUMN deal_id TEXT;
CREATE TABLE IF NOT EXISTS consents (
  id TEXT PRIMARY KEY,
  merchant_id TEXT NOT NULL,
  channel TEXT NOT NULL,
  status TEXT NOT NULL,
  timestamp DATETIME DEFAULT CURRENT_TIMESTAMP NOT NULL
);
CREATE UNIQUE INDEX IF NOT EXISTS uq_consents_merchant_channel ON consents(merchant_id, channel);


Note on offers: keep the legacy merchant_id temporarily. New writes should set deal_id. You can later backfill deal_id and drop merchant_id cleanly.

1) Idempotency dependency (FastAPI)

server/deps/idempotency.py

import hashlib, json, time
from fastapi import Header, HTTPException, Request

_CACHE = {}  # swap to Redis in prod
_TTL_SEC = 3600

def _key(tenant_id: str, idem: str, request: Request):
    body = getattr(request.state, "_body_cache", b"")
    h = hashlib.sha256(body).hexdigest()
    return f"{tenant_id}:{request.url.path}:{idem}:{h}"

async def capture_body(request: Request):
    # read once, cache for idempotency key
    body = await request.body()
    request.state._body_cache = body

async def require_idempotency(
    request: Request,
    idempotency_key: str | None = Header(default=None, alias="Idempotency-Key"),
    tenant_id: str | None = Header(default=None, alias="X-Tenant-ID"),
):
    if not idempotency_key:
        raise HTTPException(400, detail="Missing Idempotency-Key")
    if not tenant_id:
        raise HTTPException(400, detail="Missing X-Tenant-ID")
    k = _key(tenant_id, idempotency_key, request)
    now = time.time()
    # purge expired
    stale = [kk for kk, (ts, _) in _CACHE.items() if now - ts > _TTL_SEC]
    for kk in stale: _CACHE.pop(kk, None)
    # replay?
    if k in _CACHE:
        _, payload = _CACHE[k]
        raise HTTPException(status_code=208, detail=payload)  # 208: Already Reported (we'll intercept in route)
    return (tenant_id, k)

def store_idempotent(k: str, payload: dict):
    _CACHE[k] = (time.time(), payload)


In routes that use idempotency we’ll:

call await capture_body(request) as a dependency

use require_idempotency to get (tenant_id, cache_key)

on success response, call store_idempotent(cache_key, payload)

catch the 208 “Already Reported” and return e.detail as JSON

2) Merchant resolution (return open deal too)

server/routes/merchants.py

from fastapi import APIRouter, Depends, Query, HTTPException
from sqlalchemy.orm import Session
from typing import Optional
from ..db import get_db
from ..models import Merchant, Deal

router = APIRouter(prefix="/api/merchants", tags=["merchants"])

@router.get("/resolve")
def resolve_merchant(
    phone: Optional[str] = Query(None),
    email: Optional[str] = Query(None),
    ein: Optional[str] = Query(None),
    legal_name: Optional[str] = Query(None),
    state: Optional[str] = Query(None),
    db: Session = Depends(get_db),
):
    m = None; score = 0.0
    if ein:
        m = db.query(Merchant).filter(Merchant.ein == ein).first()
        score = 0.99 if m else 0.0
    if not m and (phone or email):
        q = db.query(Merchant)
        if phone: q = q.filter(Merchant.phone == phone)
        if email: q = q.filter(Merchant.email == email)
        m = q.first(); score = 0.95 if m else 0.0
    if not m and legal_name:
        # naive fuzzy (replace with proper distance if you like)
        name = (legal_name or "").lower()
        cands = db.query(Merchant).filter(Merchant.state == state if state else True).all()
        best, best_score = None, 0.0
        for c in cands:
            if not c.legal_name: continue
            ln = c.legal_name.lower()
            # quick similarity by common length ratio (cheap & safe)
            s = 1.0 - abs(len(ln) - len(name)) / max(len(name), 1)
            if s > best_score: best, best_score = c, s
        if best and best_score >= 0.9:
            m, score = best, 0.9
        elif best and best_score >= 0.75:
            return {"found": "ambiguous", "candidates": [{"id": best.id, "legal_name": best.legal_name, "score": round(best_score,2)}]}
    if not m:
        return {"found": False}

    open_deal = db.query(Deal).filter(
        Deal.merchant_id == m.id,
        Deal.status.in_(["open","offer","accepted"])
    ).order_by(Deal.created_at.desc()).first()

    return {
        "found": True,
        "merchant": {"id": m.id, "legal_name": m.legal_name, "phone": m.phone, "email": m.email, "ein": m.ein},
        "open_deal": {"id": open_deal.id, "status": open_deal.status} if open_deal else None,
        "match": {"score": round(score, 2)}
    }

3) Deals.start (reuse open deal)

server/routes/deals.py

from fastapi import APIRouter, Depends, HTTPException, Request
from sqlalchemy.orm import Session
from pydantic import BaseModel
from ..db import get_db
from ..models import Merchant, Deal, Event
from ..deps.idempotency import capture_body, require_idempotency, store_idempotent

router = APIRouter(prefix="/api/deals", tags=["deals"])

class StartDeal(BaseModel):
    merchant_id: str | None = None
    merchant_hint: dict | None = None
    create_if_missing: bool = True

@router.post("/start", dependencies=[Depends(capture_body)])
def start_deal(
    request: Request,
    payload: StartDeal,
    ide=Depends(require_idempotency),
    db: Session = Depends(get_db),
):
    try:
        tenant_id, cache_key = ide
    except HTTPException as e:
        if e.status_code == 208:  # already reported
            return e.detail
        raise

    m = None
    if payload.merchant_id:
        m = db.query(Merchant).get(payload.merchant_id)
    else:
        hint = payload.merchant_hint or {}
        q = db.query(Merchant)
        if hint.get("ein"):
            m = q.filter(Merchant.ein == hint["ein"]).first()
        if not m and (hint.get("phone") or hint.get("email")):
            q = db.query(Merchant)
            if hint.get("phone"): q = q.filter(Merchant.phone == hint["phone"])
            if hint.get("email"): q = q.filter(Merchant.email == hint["email"])
            m = q.first()
        if not m and payload.create_if_missing:
            m = Merchant(
                legal_name=hint.get("legal_name") or "Unknown",
                phone=hint.get("phone"), email=hint.get("email"),
                ein=hint.get("ein"), state=hint.get("state")
            )
            db.add(m); db.commit(); db.refresh(m)
    if not m:
        raise HTTPException(404, "Merchant not found")

    d = db.query(Deal).filter(
        Deal.merchant_id == m.id,
        Deal.status.in_(["open","offer","accepted"])
    ).order_by(Deal.created_at.desc()).first()
    if not d:
        d = Deal(merchant_id=m.id, status="open")
        db.add(d); db.commit(); db.refresh(d)

    ev = Event(tenant_id=None, merchant_id=m.id, deal_id=d.id, type="deal.start")
    db.add(ev); db.commit()
    resp = {"deal_id": d.id, "merchant_id": m.id, "status": d.status}
    store_idempotent(cache_key, resp)
    return resp

4) Intake: ask-only-what’s-missing/expired

server/routes/intake.py

from fastapi import APIRouter, Depends, HTTPException, Request
from pydantic import BaseModel
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
from ..db import get_db
from ..models import FieldState, Event
from ..deps.idempotency import capture_body, require_idempotency, store_idempotent

router = APIRouter(prefix="/api/intake", tags=["intake"])

REQUIRED = [
    "business.legal_name","business.address","business.city","business.state","business.zip",
    "contact.phone","contact.email","business.ein","owner.dob","owner.ssn_last4"
]
EXPIRES = { "contact.phone":365, "contact.email":365, "business.address":365 }  # days

class Answer(BaseModel):
    merchant_id: str
    deal_id: str
    source: str = "intake"
    answers: list[dict]  # [{field_id, value}]

@router.post("/answer", dependencies=[Depends(capture_body)])
def post_answer(
    request: Request,
    payload: Answer,
    ide=Depends(require_idempotency),
    db: Session = Depends(get_db),
):
    try:
        tenant_id, cache_key = ide
    except Exception as e:
        pass  # no-op; idempotency handled above

    if not payload.answers:
        raise HTTPException(400, "answers required")

    for a in payload.answers:
        fid, val = a.get("field_id"), a.get("value")
        if not fid:
            continue
        fs = db.query(FieldState).filter(
            FieldState.merchant_id == payload.merchant_id,
            FieldState.field_id == fid
        ).first()
        now = datetime.utcnow()
        if fs:
            fs.value = val; fs.source = payload.source; fs.last_verified_at = now
        else:
            fs = FieldState(merchant_id=payload.merchant_id, field_id=fid, value=val, source=payload.source, last_verified_at=now)
            db.add(fs)
    db.commit()

    all_fs = db.query(FieldState).filter(FieldState.merchant_id == payload.merchant_id).all()
    by_id = {f.field_id: f for f in all_fs}
    missing = [f for f in REQUIRED if f not in by_id or not str(by_id[f].value or "").strip()]
    confirm = []
    for fid, days in EXPIRES.items():
        st = by_id.get(fid)
        if st and st.last_verified_at and (datetime.utcnow() - st.last_verified_at).days > days:
            confirm.append(fid)

    ev = Event(tenant_id=None, merchant_id=payload.merchant_id, deal_id=payload.deal_id, type="intake.updated", data={"answers": payload.answers})
    db.add(ev); db.commit()

    resp = {"ok": True, "missing": missing, "confirm": confirm}
    try: store_idempotent(cache_key, resp)
    except: pass
    return resp

5) Bank statements → metrics on the deal

server/routes/documents.py

from fastapi import APIRouter, Depends, File, UploadFile, HTTPException, Query
from sqlalchemy.orm import Session
import os, shutil
from ..db import get_db
from ..models import BankDocument, MetricsSnapshot, Event

router = APIRouter(prefix="/api/documents", tags=["documents"])

DATA_DIR = os.path.join(os.getcwd(), "data", "docs")
os.makedirs(DATA_DIR, exist_ok=True)

@router.post("/bank/upload")
async def upload_bank_statements(
    merchant_id: str = Query(...),
    deal_id: str = Query(...),
    files: list[UploadFile] = File(...),
    db: Session = Depends(get_db),
):
    if len(files) != 3:
        raise HTTPException(400, detail="Exactly 3 PDFs required")
    created = []
    for f in files:
        fn = f.filename or "statement.pdf"
        dst = os.path.join(DATA_DIR, fn.replace("/", "_"))
        with open(dst, "wb") as out:
            shutil.copyfileobj(f.file, out)
        doc = BankDocument(deal_id=deal_id, filename=fn, path=dst, parsed=False)
        db.add(doc); db.commit(); db.refresh(doc)
        created.append({"id": doc.id, "filename": doc.filename})
    # TODO: call your OpenAI parser here; stub metrics for now
    metrics = {"avg_monthly_revenue": 80000, "avg_daily_balance_3m": 12000, "total_nsf_3m": 1, "total_days_negative_3m": 2}
    snap = MetricsSnapshot(deal_id=deal_id, source="statements", payload=metrics)
    db.add(snap)
    db.add(Event(tenant_id=None, merchant_id=merchant_id, deal_id=deal_id, type="metrics.ready", data=metrics))
    db.commit()
    return {"ok": True, "documents": created, "metrics": metrics}

6) Offers tied to deal_id + guardrails

server/services/underwriting.py (guardrails)

def pre_offer_checks(metrics: dict, state: str | None = None):
    is_ca = (state or "").upper() == "CA"
    months = metrics.get("months_covered", 3)
    if is_ca and months < 4:
        return False, "CA requires 4 months statements"
    if metrics.get("total_nsf_3m", 0) > 3:
        return False, "Excessive NSF"
    if metrics.get("total_days_negative_3m", 0) > 6:
        return False, "Excessive negative days"
    return True, None


server/routes/offers.py

from fastapi import APIRouter, Depends, HTTPException, Path
from sqlalchemy.orm import Session
from ..db import get_db
from ..models import MetricsSnapshot, Offer, Deal, Event
from ..services.underwriting import pre_offer_checks
from ..services.offers_engine import generate_offers  # your existing deterministic engine

router = APIRouter(prefix="/api", tags=["offers"])

@router.post("/deals/{deal_id}/offers")
def create_offers(
    deal_id: str = Path(...),
    overrides: dict | None = None,
    db: Session = Depends(get_db),
):
    snap = db.query(MetricsSnapshot).filter(MetricsSnapshot.deal_id == deal_id).orderBy(MetricsSnapshot.created_at.desc()).first()
    if not snap:
        raise HTTPException(400, "No metrics snapshot for deal")
    deal = db.query(Deal).get(deal_id)
    ok, reason = pre_offer_checks(snap.payload or {}, getattr(deal, "state", None))
    if not ok:
        db.add(Event(tenant_id=None, merchant_id=deal.merchant_id, deal_id=deal_id, type="offers.blocked", data={"reason": reason}))
        db.commit()
        return {"offers": [], "blocked": True, "reason": reason}
    offers = generate_offers(snap.payload or {}, overrides or {})
    created = []
    for o in offers:
        rec = Offer(deal_id=deal_id, payload=o)
        db.add(rec); db.commit(); db.refresh(rec)
        created.append(o)
    db.add(Event(tenant_id=None, merchant_id=deal.merchant_id, deal_id=deal_id, type="offers.generated", data={"count": len(created)}))
    db.commit()
    return {"offers": created}

7) Cherry SMS + Consent

server/routes/sms.py

from fastapi import APIRouter, Depends, Header, HTTPException, Request
from pydantic import BaseModel
from sqlalchemy.orm import Session
from ..db import get_db
from ..models import Consent, Event
import uuid

router = APIRouter(prefix="/api/sms/cherry", tags=["sms"])

class SMSMessage(BaseModel):
    to: str
    body: str
    merchant_id: str | None = None

class SMSPayload(BaseModel):
    campaignName: str
    messages: list[SMSMessage]

def ensure_stop(body: str):
    return body if "stop to opt out" in body.lower() else f"{body} Reply STOP to opt out."

@router.post("/send")
def send_sms(
    payload: SMSPayload,
    authorization: str | None = Header(default=None, alias="Authorization"),
    idem: str | None = Header(default=None, alias="Idempotency-Key"),
    db: Session = Depends(get_db),
):
    if not idem:
        raise HTTPException(400, "Missing Idempotency-Key")
    # In prod: auth + connector config lookup by tenant
    sent = 0
    for m in payload.messages:
        # skip opt-outs
        if m.merchant_id:
            c = db.query(Consent).filter(Consent.merchant_id==m.merchant_id, Consent.channel=="sms").first()
            if c and c.status == "opt_out": continue
        body = ensure_stop(m.body)
        # TODO: call Cherry API here. For now, pretend queued.
        sent += 1
        db.add(Event(tenant_id=None, merchant_id=m.merchant_id, deal_id=None, type="sms.queued", data={"to": m.to}))
    db.commit()
    return {"campaign_id": str(uuid.uuid4()), "queued": sent}

@router.post("/webhook")
async def webhook(req: Request, db: Session = Depends(get_db)):
    body = await req.json()
    # Example inbound STOP
    if (body.get("type") == "inbound") and (body.get("text","").strip().upper() == "STOP"):
        phone = body.get("from")
        # find merchant by phone (simple)
        from ..models import Merchant
        m = db.query(Merchant).filter(Merchant.phone == phone).first()
        if m:
            c = db.query(Consent).filter(Consent.merchant_id == m.id, Consent.channel=="sms").first()
            if c: c.status = "opt_out"
            else: db.add(Consent(merchant_id=m.id, channel="sms", status="opt_out"))
            db.add(Event(tenant_id=None, merchant_id=m.id, deal_id=None, type="sms.stop", data={"from": phone}))
            db.commit()
    return {"ok": True}


Include the router in your app:

# server/main.py (or wherever you assemble FastAPI)
from server.routes import merchants, deals, intake, documents, offers, sms
app.include_router(merchants.router)
app.include_router(deals.router)
app.include_router(intake.router)
app.include_router(documents.router)
app.include_router(offers.router)
app.include_router(sms.router)

8) Events: start writing tenant_id + deal_id

In each route above, we’re already adding Event(tenant_id=..., merchant_id=..., deal_id=..., type=..., data=...). If your Event model didn’t include these fields, make sure the model matches the migration.

9) Quick self-test (should all 200)
# 1) Resolve (unknown/new)
curl -s "http://localhost:8000/api/merchants/resolve?phone=9735550188"

# 2) Start or reuse open deal
curl -s -X POST http://localhost:8000/api/deals/start \
  -H "Content-Type: application/json" -H "X-Tenant-ID:T1" -H "Idempotency-Key:abc1" \
  -d '{"merchant_hint":{"phone":"9735550188","legal_name":"Maple Deli LLC"},"create_if_missing":true}'

# Use the returned merchant_id/deal_id for the rest:
MID="<MID>"; DID="<DID>"

# 3) Intake answer (ask-only)
curl -s -X POST http://localhost:8000/api/intake/answer \
  -H "Content-Type: application/json" -H "X-Tenant-ID:T1" -H "Idempotency-Key:abc2" \
  -d "{\"merchant_id\":\"$MID\",\"deal_id\":\"$DID\",\"source\":\"intake\", \"answers\":[{\"field_id\":\"owner.ssn_last4\",\"value\":\"1234\"}]}"

# 4) Upload 3 PDFs (adjust file paths)
curl -s -X POST "http://localhost:8000/api/documents/bank/upload?merchant_id=$MID&deal_id=$DID" \
  -F "files=@/path/jun.pdf" -F "files=@/path/jul.pdf" -F "files=@/path/aug.pdf"

# 5) Offers (should return 1–3 offers or blocked with reason)
curl -s -X POST "http://localhost:8000/api/deals/$DID/offers" -H "Content-Type: application/json" -d "{}"

# 6) SMS send (mock)
curl -s -X POST http://localhost:8000/api/sms/cherry/send \
  -H "Content-Type: application/json" -H "Idempotency-Key:abc3" \
  -d '{"campaignName":"Test","messages":[{"to":"+19735550188","body":"Hi from UW Wizard","merchant_id":"'$MID'"}]}'

That’s everything you needed to reach minimum viable automation:

Returning vs new merchant, reusing open deals ✅

Intake that only asks for missing/expired fields ✅

Statements attach to deals + metrics snapshot ✅

Offers tied to deals with guardrails ✅

Consent + SMS send/webhook ✅

Events enriched with tenant/deal ✅

Idempotency for safe retries ✅