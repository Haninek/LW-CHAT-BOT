awesome — here’s a ready-to-PR package: a single branch plan, a PR body you can paste, and a consolidated, file-by-file patch list (new files + edits). Use it as-is or tweak names.

0) Branch & commit flow
git checkout -b feat/pilot-readiness
# add/replace files per the patches below…
git add server server/routes server/services alembic/versions
git commit -m "Pilot readiness: events(deal_id/tenant_id), Redis idempotency, secure docs (S3+AV), SMS consent/STOP, CORS/Settings"
git push -u origin feat/pilot-readiness

1) Pull-request title

Pilot readiness: events(deal_id/tenant_id), Redis idempotency, S3+AV docs, SMS consent/STOP, CORS/Settings

2) Pull-request body (paste this)
Why

Prepares UW Wizard for a controlled pilot. Closes gaps we identified:

missing deal_id on events

no idempotency on FastAPI writes

document security (S3, MIME/size, AV scan) + “exactly three PDFs”

SMS blast + consent/STOP handling

incomplete Settings/CORS/config

What’s in

Config: restored Settings with DATABASE_URL, REDIS_URL, CORS_ORIGINS, S3 creds, webhook secrets.

Events: migration adds tenant_id, deal_id + best-effort backfill from JSON; writers updated to set both.

Idempotency: Redis-backed dependency for POST routes (/deals/start, /intake/answer, /documents/bank/upload, /deals/{id}/offers, /background/run, /sign/send, /sms/cherry/send).

Docs security: S3 private storage, MIME/size checks, optional ClamAV scan, and strict “exactly 3 PDFs”.

SMS: consents table, POST /api/sms/cherry/send with per-tenant rate-limit + STOP footer, inbound /webhook to flip opt-out & event.

CORS: locked to configured origins; no wildcard in prod.

Migrations

uwizard_events_dealid — add events.tenant_id + events.deal_id (+ backfill)

uwizard_documents_s3 — add bank_documents.storage_key/bucket/checksum (move away from BLOBs)

uwizard_consents — create consents with unique phone

Run:

alembic upgrade head

Breaking/attention

Env vars needed (see Config below).

If you stored statement PDFs as blobs, this patch stops writing blobs and writes S3 metadata instead (existing blobs unaffected unless you dropped the column).

Admin/queries should now filter events by deal_id column, not JSON.

Config (.env.example)
APP_NAME=UW Wizard
DEBUG=false
PORT=8000
DATABASE_URL=postgresql+psycopg://user:pass@host:5432/uwizard   # or sqlite:///./uwizard.db for dev
REDIS_URL=redis://localhost:6379/0
CORS_ORIGINS=https://your-admin.app,https://your-widget.host
AWS_REGION=us-east-1
AWS_ACCESS_KEY_ID=xxxxx
AWS_SECRET_ACCESS_KEY=xxxxx
S3_BUCKET=uwizard-private
DOCUSIGN_WEBHOOK_SECRET=xxxxx         # or DROPBOXSIGN_WEBHOOK_SECRET
CHERRY_API_KEY=xxxxx
MOCK_MODE=false

Test plan (smoke)

Start/reuse deal → intake ask-only → upload 3 PDFs → offers (guardrails) → accept → background (flags-only) → sign (blocked unless OK / force) → SMS send (rate-limited & STOP footer) → inbound STOP flips consent.

(Use the curl set we shared earlier.)

Rollback

alembic downgrade -1 for each revision (note S3 vs blob storage is one-way for new uploads).

3) Consolidated patch list

Where I say “NEW FILE”, create it. Where I say “EDIT”, replace the handler/content as shown. If your paths differ slightly, adapt the imports.

A) Config / CORS

EDIT server/core/config.py

from functools import lru_cache
from pydantic import BaseSettings
from typing import List

class Settings(BaseSettings):
    APP_NAME: str = "UW Wizard"
    DEBUG: bool = True
    PORT: int = 8000

    DATABASE_URL: str = "sqlite:///./uwizard.db"
    REDIS_URL: str = "redis://localhost:6379/0"

    CORS_ORIGINS: str = "http://localhost:5173,http://localhost:3000"

    AWS_REGION: str = "us-east-1"
    AWS_ACCESS_KEY_ID: str = ""
    AWS_SECRET_ACCESS_KEY: str = ""
    S3_BUCKET: str = "uwizard-private"

    DOCUSIGN_WEBHOOK_SECRET: str = ""
    DROPBOXSIGN_WEBHOOK_SECRET: str = ""
    CHERRY_API_KEY: str = ""

    MOCK_MODE: bool = True

    @property
    def cors_origins_list(self) -> List[str]:
        return [o.strip() for o in self.CORS_ORIGINS.split(",") if o.strip()]

    class Config:
        env_file = ".env"
        case_sensitive = True

@lru_cache()
def get_settings() -> Settings:
    return Settings()


EDIT server/main.py (ensure CORS uses the list & include new routers later)

from server.core.config import get_settings
from fastapi.middleware.cors import CORSMiddleware

settings = get_settings()
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.cors_origins_list,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

B) Events migration + writer updates

NEW FILE alembic/versions/uwizard_events_dealid.py

from alembic import op
import sqlalchemy as sa

revision = "uwizard_events_dealid"
down_revision = "<PUT_PREV_REVISION>"
branch_labels = None
depends_on = None

def upgrade():
    with op.batch_alter_table("events") as b:
        b.add_column(sa.Column("tenant_id", sa.String(), nullable=True))
        b.add_column(sa.Column("deal_id", sa.String(), nullable=True))
    op.create_index("ix_events_tenant_id", "events", ["tenant_id"])
    op.create_index("ix_events_deal_id", "events", ["deal_id"])

    conn = op.get_bind()
    dialect = conn.dialect.name
    if dialect == "postgresql":
        conn.execute(sa.text("UPDATE events SET deal_id = COALESCE(deal_id, (data->>'deal_id'))"))
    else:
        conn.execute(sa.text("UPDATE events SET deal_id = COALESCE(deal_id, json_extract(data, '$.deal_id'))"))

def downgrade():
    op.drop_index("ix_events_deal_id", table_name="events")
    op.drop_index("ix_events_tenant_id", table_name="events")
    with op.batch_alter_table("events") as b:
        b.drop_column("deal_id"); b.drop_column("tenant_id")


EDIT all event writers to set tenant_id and deal_id. Example:

server/routes/background.py

db.add(Event(tenant_id=tenant_id, merchant_id=m.id, deal_id=deal_id,
             type="background.result", data={"status": status, "reasons": reasons}))


server/routes/sign.py (send + webhook)

db.add(Event(tenant_id=tenant_id, merchant_id=deal.merchant_id, deal_id=deal_id,
             type="sign.sent", data={"to": recipient_email, "force": force}))


server/routes/deals_actions.py

db.add(Event(tenant_id=tenant_id, merchant_id=d.merchant_id, deal_id=deal_id,
             type="offer.accepted", data=offer))


(If you don’t already pass tenant_id in headers, default to None until multi-tenant is wired.)

C) Redis idempotency

NEW FILE server/core/idempotency.py

import hashlib, json
from typing import Optional
from fastapi import Header, HTTPException, Request
from redis.asyncio import from_url as redis_from_url
from .config import get_settings

S = get_settings()
R = redis_from_url(S.REDIS_URL, encoding="utf-8", decode_responses=True)
TTL = 3600

async def capture_body(request: Request):
    request.state._body_cache = await request.body()

def _key(tenant_id: str, path: str, idem: str, body: bytes) -> str:
    h = hashlib.sha256(body or b"").hexdigest()
    return f"idem:{tenant_id}:{path}:{idem}:{h}"

async def require_idempotency(
    request: Request,
    idempotency_key: Optional[str] = Header(None, alias="Idempotency-Key"),
    tenant_id: Optional[str] = Header(None, alias="X-Tenant-ID"),
):
    if not idempotency_key:
        raise HTTPException(400, "Missing Idempotency-Key")
    if not tenant_id:
        raise HTTPException(400, "Missing X-Tenant-ID")
    key = _key(tenant_id, request.url.path, idempotency_key, getattr(request.state, "_body_cache", b""))
    cached = await R.get(key)
    if cached:
        request.state.idem_cached = json.loads(cached)
    request.state.idem_key = key
    request.state.tenant_id = tenant_id
    return tenant_id

async def store_idempotent(request: Request, payload: dict):
    key = getattr(request.state, "idem_key", None)
    if key:
        await R.set(key, json.dumps(payload), ex=TTL)


EDIT each POST route (pattern):

# top of file
from fastapi import Depends, Request
from server.core.idempotency import capture_body, require_idempotency, store_idempotent

@router.post("/<your-path>", dependencies=[Depends(capture_body)])
async def handler(request: Request, tenant_id=Depends(require_idempotency), ...):
    if getattr(request.state, "idem_cached", None):
        return request.state.idem_cached
    # ... your logic ...
    resp = {...}
    await store_idempotent(request, resp)
    return resp


Apply to:

/api/deals/start

/api/intake/answer

/api/documents/bank/upload

/api/deals/{deal_id}/offers

/api/background/run

/api/sign/send

(new) /api/sms/cherry/send

D) Document security: S3 + MIME/size + ClamAV

NEW FILE server/services/storage.py

import boto3, hashlib
from botocore.client import Config
from ..core.config import get_settings
S = get_settings()
_s3 = boto3.client("s3", region_name=S.AWS_REGION,
                   aws_access_key_id=S.AWS_ACCESS_KEY_ID or None,
                   aws_secret_access_key=S.AWS_SECRET_ACCESS_KEY or None,
                   config=Config(signature_version="s3v4"))

def _sha256(b: bytes) -> str:
    import hashlib; h = hashlib.sha256(); h.update(b); return h.hexdigest()

def put_private(data: bytes, key: str, content_type: str):
    _s3.put_object(Bucket=S.S3_BUCKET, Key=key, Body=data, ContentType=content_type, ACL="private")
    return {"bucket": S.S3_BUCKET, "key": key, "checksum": _sha256(data)}


NEW FILE (optional) server/services/antivirus.py

import os
try:
    import clamd
except Exception:
    clamd = None

def scan_bytes(data: bytes):
    if not clamd:  # no-op if lib not installed
        return
    host = os.getenv("CLAMD_HOST", "localhost")
    port = int(os.getenv("CLAMD_PORT", "3310"))
    cd = clamd.ClamdNetworkSocket(host, port)
    res = cd.instream(data)
    st = (res or {}).get("stream", ["OK"])[0]
    if st != "OK":
        raise ValueError(f"Virus detected: {st}")


NEW FILE alembic/versions/uwizard_documents_s3.py

from alembic import op
import sqlalchemy as sa

revision = "uwizard_documents_s3"
down_revision = "uwizard_events_dealid"
branch_labels = None
depends_on = None

def upgrade():
    with op.batch_alter_table("bank_documents") as b:
        b.add_column(sa.Column("storage_key", sa.String(), nullable=True))
        b.add_column(sa.Column("bucket", sa.String(), nullable=True))
        b.add_column(sa.Column("checksum", sa.String(), nullable=True))

def downgrade():
    with op.batch_alter_table("bank_documents") as b:
        b.drop_column("checksum"); b.drop_column("bucket"); b.drop_column("storage_key")


EDIT server/routes/documents.py (replace upload handler)

from fastapi import APIRouter, Depends, File, UploadFile, HTTPException, Query, Request
from sqlalchemy.orm import Session
from ..db import get_db
from ..models import BankDocument, MetricsSnapshot, Event
from ..services.storage import put_private
from ..services.antivirus import scan_bytes
from server.core.idempotency import capture_body, require_idempotency, store_idempotent

router = APIRouter(prefix="/api/documents", tags=["documents"])
MAX_PDF = 12 * 1024 * 1024

@router.post("/bank/upload", dependencies=[Depends(capture_body)])
async def upload_bank_statements(
    request: Request,
    merchant_id: str = Query(...),
    deal_id: str = Query(...),
    files: list[UploadFile] = File(...),
    db: Session = Depends(get_db),
    tenant_id=Depends(require_idempotency)
):
    if getattr(request.state, "idem_cached", None):
        return request.state.idem_cached
    if len(files) != 3:
        raise HTTPException(400, "Exactly 3 PDF statements are required")
    stored = []
    for f in files:
        if f.content_type not in ("application/pdf", "application/x-pdf"):
            raise HTTPException(400, f"{f.filename}: only PDF allowed")
        content = await f.read()
        if len(content) > MAX_PDF:
            raise HTTPException(400, f"{f.filename}: too large")
        scan_bytes(content)
        key = f"statements/{deal_id}/{f.filename}"
        meta = put_private(content, key, "application/pdf")
        rec = BankDocument(deal_id=deal_id, filename=f.filename,
                           storage_key=meta["key"], bucket=meta["bucket"], checksum=meta["checksum"], parsed=False)
        db.add(rec); db.commit(); db.refresh(rec)
        stored.append({"id": rec.id, "filename": rec.filename})

    # TODO parse; stub metrics:
    metrics = {"avg_monthly_revenue": 80000, "avg_daily_balance_3m": 12000, "total_nsf_3m": 1, "total_days_negative_3m": 2}
    snap = MetricsSnapshot(deal_id=deal_id, source="statements", payload=metrics)
    db.add(snap)
    db.add(Event(tenant_id=tenant_id, merchant_id=merchant_id, deal_id=deal_id, type="metrics.ready", data=metrics))
    db.commit()
    resp = {"ok": True, "documents": stored, "metrics": metrics}
    await store_idempotent(request, resp)
    return resp

E) SMS consent + send + STOP webhook

NEW FILE alembic/versions/uwizard_consents.py

from alembic import op
import sqlalchemy as sa

revision = "uwizard_consents"
down_revision = "uwizard_documents_s3"
branch_labels = None
depends_on = None

def upgrade():
    op.create_table(
        "consents",
        sa.Column("id", sa.String(), primary_key=True),
        sa.Column("merchant_id", sa.String(), nullable=True),
        sa.Column("phone", sa.String(), nullable=False),
        sa.Column("channel", sa.String(), nullable=False),
        sa.Column("status", sa.String(), nullable=False),
        sa.Column("created_at", sa.DateTime(), server_default=sa.func.now(), nullable=False),
        sa.Column("updated_at", sa.DateTime(), server_default=sa.func.now(), onupdate=sa.func.now(), nullable=False),
    )
    op.create_index("ix_consents_phone", "consents", ["phone"], unique=True)

def downgrade():
    op.drop_index("ix_consents_phone", table_name="consents")
    op.drop_table("consents")


NEW FILE server/routes/sms.py

from fastapi import APIRouter, Depends, Header, HTTPException, Request
from pydantic import BaseModel
from sqlalchemy.orm import Session
from typing import List, Optional
from ..db import get_db
from ..models import Consent, Event, Merchant
from ..core.idempotency import capture_body, require_idempotency, store_idempotent
from ..core.config import get_settings
from redis.asyncio import from_url as redis_from_url
import re, uuid, time, httpx

S = get_settings()
R = redis_from_url(S.REDIS_URL, encoding="utf-8", decode_responses=True)
router = APIRouter(prefix="/api/sms/cherry", tags=["sms"])

class SMSMessage(BaseModel):
    to: str
    body: str
    merchant_id: Optional[str] = None

class SMSPayload(BaseModel):
    campaignName: str
    messages: List[SMSMessage]

FOOTER = " Reply STOP to opt out."
PHONE_RE = re.compile(r"^\+?[1-9]\d{7,14}$")

async def rate_limit(tenant_id: str, count: int, limit: int = 2000, window_sec: int = 60):
    key = f"rt:sms:{tenant_id}"
    now = int(time.time())
    await R.zremrangebyscore(key, 0, now - window_sec)
    await R.zadd(key, {str(uuid.uuid4()): now})
    await R.expire(key, window_sec + 5)
    size = await R.zcard(key)
    if int(size) + count > limit:
        raise HTTPException(429, "Rate limit exceeded")

@router.post("/send", dependencies=[Depends(capture_body)])
async def send_sms(request: Request, payload: SMSPayload, tenant_id=Depends(require_idempotency), db: Session = Depends(get_db)):
    if getattr(request.state, "idem_cached", None):
        return request.state.idem_cached
    await rate_limit(tenant_id, len(payload.messages))
    queued = 0
    out = []
    for m in payload.messages:
        if not PHONE_RE.match(m.to): continue
        c = db.query(Consent).filter(Consent.phone == m.to, Consent.channel == "sms").first()
        if c and c.status == "opt_out": continue
        body = m.body if "stop to opt out" in m.body.lower() else m.body + FOOTER
        out.append({"to": m.to, "body": body})
        db.add(Event(tenant_id=tenant_id, merchant_id=m.merchant_id, deal_id=None, type="sms.queued", data={"to": m.to, "campaign": payload.campaignName}))
        queued += 1
    db.commit()

    # TODO: call Cherry provider or your relay
    # async with httpx.AsyncClient(timeout=30) as client: await client.post(..., json={"messages": out})

    resp = {"campaign": payload.campaignName, "queued": queued}
    await store_idempotent(request, resp)
    return resp

@router.post("/webhook")
async def webhook(req: Request, db: Session = Depends(get_db)):
    body = await req.json()
    if (body.get("type") == "inbound") and str(body.get("text", "")).strip().upper() == "STOP":
        phone = body.get("from")
        c = db.query(Consent).filter(Consent.phone == phone, Consent.channel == "sms").first()
        if c: c.status = "opt_out"
        else: db.add(Consent(phone=phone, channel="sms", status="opt_out"))
        m = db.query(Merchant).filter(Merchant.phone == phone).first()
        db.add(Event(tenant_id=None, merchant_id=getattr(m, "id", None), deal_id=None, type="sms.stop", data={"from": phone}))
        db.commit()
    return {"ok": True}


EDIT server/main.py to include the router:

from server.routes import sms as sms_routes
app.include_router(sms_routes.router)