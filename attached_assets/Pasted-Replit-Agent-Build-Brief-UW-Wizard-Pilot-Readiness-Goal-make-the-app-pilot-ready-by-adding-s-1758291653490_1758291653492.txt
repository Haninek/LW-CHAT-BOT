Replit Agent Build Brief — “UW Wizard” Pilot Readiness

Goal: make the app pilot-ready by adding:

solid config & CORS, 2) events.deal_id/tenant_id + backfill, 3) Redis-based idempotency for POSTs, 4) secure doc uploads (S3 + MIME/size + optional ClamAV, with local fallback), 5) SMS consent + STOP webhook + rate-limited sender, 6) wire routes and provide smoke tests.

Repo layout assumption: FastAPI backend under server/, Alembic under alembic/, React under web/. If folders differ, adapt paths consistently.

0) Dependencies & env

Add to requirements (pip or poetry):

redis>=5.0
boto3>=1.34
botocore>=1.34
httpx>=0.27
pydantic>=1.10


Optional (only if you’ll run AV scanning now):

clamd>=1.0


Replit Secrets / .env (create if missing):

APP_NAME=UW Wizard
DEBUG=true
PORT=8000
DATABASE_URL=sqlite:///./uwizard.db
REDIS_URL=redis://localhost:6379/0    # For Replit, set to a managed Redis like Upstash if local Redis isn’t available
CORS_ORIGINS=http://localhost:5173,http://localhost:3000

AWS_REGION=us-east-1
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
S3_BUCKET=uwizard-private

DOCUSIGN_WEBHOOK_SECRET=
DROPBOXSIGN_WEBHOOK_SECRET=
CHERRY_API_KEY=

MOCK_MODE=true     # true = use local disk instead of S3; idempotency still needs Redis unless you set a working REDIS_URL

1) Config & CORS

Create/Replace server/core/config.py:

from functools import lru_cache
from pydantic import BaseSettings
from typing import List

class Settings(BaseSettings):
    APP_NAME: str = "UW Wizard"
    DEBUG: bool = True
    PORT: int = 8000

    DATABASE_URL: str = "sqlite:///./uwizard.db"
    REDIS_URL: str = "redis://localhost:6379/0"

    # Comma-separated origins. No wildcard in prod.
    CORS_ORIGINS: str = "http://localhost:5173,http://localhost:3000"

    AWS_REGION: str = "us-east-1"
    AWS_ACCESS_KEY_ID: str = ""
    AWS_SECRET_ACCESS_KEY: str = ""
    S3_BUCKET: str = "uwizard-private"

    DOCUSIGN_WEBHOOK_SECRET: str = ""
    DROPBOXSIGN_WEBHOOK_SECRET: str = ""
    CHERRY_API_KEY: str = ""

    # If true, storage falls back to local disk instead of S3.
    MOCK_MODE: bool = True

    @property
    def cors_origins_list(self) -> List[str]:
        return [o.strip() for o in self.CORS_ORIGINS.split(",") if o.strip()]

    class Config:
        env_file = ".env"
        case_sensitive = True

@lru_cache()
def get_settings() -> Settings:
    return Settings()


Ensure server/main.py uses the list:

from server.core.config import get_settings
from fastapi.middleware.cors import CORSMiddleware
settings = get_settings()
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.cors_origins_list,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

2) Events: add deal_id + tenant_id and backfill

Create alembic/versions/uwizard_events_dealid.py (set down_revision to your latest existing revision id):

from alembic import op
import sqlalchemy as sa

revision = "uwizard_events_dealid"
down_revision = "<PUT_PREV_REVISION>"
branch_labels = None
depends_on = None

def upgrade():
    with op.batch_alter_table("events") as b:
        b.add_column(sa.Column("tenant_id", sa.String(), nullable=True))
        b.add_column(sa.Column("deal_id", sa.String(), nullable=True))
    op.create_index("ix_events_tenant_id", "events", ["tenant_id"])
    op.create_index("ix_events_deal_id", "events", ["deal_id"])

    conn = op.get_bind()
    dialect = conn.dialect.name
    if dialect == "postgresql":
        conn.execute(sa.text("UPDATE events SET deal_id = COALESCE(deal_id, (data->>'deal_id'))"))
    else:
        conn.execute(sa.text("UPDATE events SET deal_id = COALESCE(deal_id, json_extract(data, '$.deal_id'))"))

def downgrade():
    op.drop_index("ix_events_deal_id", table_name="events")
    op.drop_index("ix_events_tenant_id", table_name="events")
    with op.batch_alter_table("events") as b:
        b.drop_column("deal_id")
        b.drop_column("tenant_id")


Update all event writes to set tenant_id and deal_id. Example edits:

In server/routes/background.py where you write background result, change to:

db.add(Event(tenant_id=getattr(request.state, "tenant_id", None),
             merchant_id=m.id, deal_id=deal_id,
             type="background.result", data={"status": status, "reasons": reasons}))


In server/routes/sign.py when sending:

db.add(Event(tenant_id=getattr(request.state, "tenant_id", None),
             merchant_id=deal.merchant_id, deal_id=deal_id,
             type="sign.sent", data={"to": recipient_email, "force": force}))


In server/routes/deals_actions.py on accept:

db.add(Event(tenant_id=getattr(request.state, "tenant_id", None),
             merchant_id=d.merchant_id, deal_id=deal_id,
             type="offer.accepted", data=offer))


(Apply the same pattern to other event writes.)

3) Redis idempotency dependency

Create server/core/idempotency.py:

import hashlib, json
from typing import Optional
from fastapi import Header, HTTPException, Request
from redis.asyncio import from_url as redis_from_url
from .config import get_settings

S = get_settings()
R = redis_from_url(S.REDIS_URL, encoding="utf-8", decode_responses=True)
TTL = 3600

async def capture_body(request: Request):
    request.state._body_cache = await request.body()

def _key(tenant_id: str, path: str, idem: str, body: bytes) -> str:
    h = hashlib.sha256(body or b"").hexdigest()
    return f"idem:{tenant_id}:{path}:{idem}:{h}"

async def require_idempotency(
    request: Request,
    idempotency_key: Optional[str] = Header(None, alias="Idempotency-Key"),
    tenant_id: Optional[str] = Header(None, alias="X-Tenant-ID"),
):
    if not idempotency_key:
        raise HTTPException(400, "Missing Idempotency-Key")
    if not tenant_id:
        raise HTTPException(400, "Missing X-Tenant-ID")
    request.state.tenant_id = tenant_id
    key = _key(tenant_id, request.url.path, idempotency_key, getattr(request.state, "_body_cache", b""))
    cached = await R.get(key)
    if cached:
        request.state.idem_cached = json.loads(cached)
    request.state.idem_key = key
    return tenant_id

async def store_idempotent(request: Request, payload: dict):
    key = getattr(request.state, "idem_key", None)
    if key:
        await R.set(key, json.dumps(payload), ex=TTL)


Wrap these POST routes with idempotency (add imports and the dependency pattern):

/api/deals/start

/api/intake/answer

/api/documents/bank/upload

/api/deals/{deal_id}/offers

/api/background/run

/api/sign/send

/api/sms/cherry/send

Pattern to apply inside each route file:

from fastapi import Depends, Request
from server.core.idempotency import capture_body, require_idempotency, store_idempotent

@router.post("<path>", dependencies=[Depends(capture_body)])
async def handler(request: Request, tenant_id=Depends(require_idempotency), ...):
    if getattr(request.state, "idem_cached", None):
        return request.state.idem_cached
    # ... do work producing resp ...
    await store_idempotent(request, resp)
    return resp

4) Secure docs: S3 + MIME/size + AV (with local fallback)

Create server/services/storage.py:

import os, hashlib, pathlib
from botocore.client import Config
import boto3
from ..core.config import get_settings
S = get_settings()

def _sha256(b: bytes) -> str:
    h = hashlib.sha256(); h.update(b); return h.hexdigest()

def put_private(data: bytes, key: str, content_type: str):
    # Local fallback when MOCK_MODE=true or missing AWS creds/bucket
    if S.MOCK_MODE or not (S.AWS_ACCESS_KEY_ID and S.AWS_SECRET_ACCESS_KEY and S.S3_BUCKET):
        base = pathlib.Path("./data/uploads")
        base.mkdir(parents=True, exist_ok=True)
        path = base / key.replace("/", "__")
        path.write_bytes(data)
        return {"bucket": "local", "key": str(path), "checksum": _sha256(data)}
    s3 = boto3.client(
        "s3",
        region_name=S.AWS_REGION,
        aws_access_key_id=S.AWS_ACCESS_KEY_ID,
        aws_secret_access_key=S.AWS_SECRET_ACCESS_KEY,
        config=Config(signature_version="s3v4"),
    )
    s3.put_object(Bucket=S.S3_BUCKET, Key=key, Body=data, ContentType=content_type, ACL="private")
    return {"bucket": S.S3_BUCKET, "key": key, "checksum": _sha256(data)}


Create (optional) server/services/antivirus.py:

import os
try:
    import clamd
except Exception:
    clamd = None

def scan_bytes(data: bytes):
    if not clamd:
        return
    host = os.getenv("CLAMD_HOST", "localhost")
    port = int(os.getenv("CLAMD_PORT", "3310"))
    cd = clamd.ClamdNetworkSocket(host, port)
    res = cd.instream(data)
    st = (res or {}).get("stream", ["OK"])[0]
    if st != "OK":
        raise ValueError(f"Virus detected: {st}")


Create alembic/versions/uwizard_documents_s3.py (set down_revision to uwizard_events_dealid or your next latest):

from alembic import op
import sqlalchemy as sa

revision = "uwizard_documents_s3"
down_revision = "uwizard_events_dealid"
branch_labels = None
depends_on = None

def upgrade():
    with op.batch_alter_table("bank_documents") as b:
        b.add_column(sa.Column("storage_key", sa.String(), nullable=True))
        b.add_column(sa.Column("bucket", sa.String(), nullable=True))
        b.add_column(sa.Column("checksum", sa.String(), nullable=True))

def downgrade():
    with op.batch_alter_table("bank_documents") as b:
        b.drop_column("checksum"); b.drop_column("bucket"); b.drop_column("storage_key")


Edit server/routes/documents.py upload handler (replace existing upload endpoint body with this hardened one):

from fastapi import APIRouter, Depends, File, UploadFile, HTTPException, Query, Request
from sqlalchemy.orm import Session
from ..db import get_db
from ..models import BankDocument, MetricsSnapshot, Event
from ..services.storage import put_private
from ..services.antivirus import scan_bytes
from server.core.idempotency import capture_body, require_idempotency, store_idempotent

router = APIRouter(prefix="/api/documents", tags=["documents"])
MAX_PDF = 12 * 1024 * 1024

@router.post("/bank/upload", dependencies=[Depends(capture_body)])
async def upload_bank_statements(
    request: Request,
    merchant_id: str = Query(...),
    deal_id: str = Query(...),
    files: list[UploadFile] = File(...),
    db: Session = Depends(get_db),
    tenant_id=Depends(require_idempotency),
):
    if getattr(request.state, "idem_cached", None):
        return request.state.idem_cached
    if len(files) != 3:
        raise HTTPException(400, "Exactly 3 PDF statements are required")
    stored = []
    for f in files:
        if f.content_type not in ("application/pdf", "application/x-pdf"):
            raise HTTPException(400, f"{f.filename}: only PDF allowed")
        content = await f.read()
        if len(content) > MAX_PDF:
            raise HTTPException(400, f"{f.filename}: too large")
        scan_bytes(content)  # no-op if clamd missing
        key = f"statements/{deal_id}/{f.filename}"
        meta = put_private(content, key, "application/pdf")
        rec = BankDocument(deal_id=deal_id, filename=f.filename,
                           storage_key=meta["key"], bucket=meta["bucket"], checksum=meta["checksum"], parsed=False)
        db.add(rec); db.commit(); db.refresh(rec)
        stored.append({"id": rec.id, "filename": rec.filename})

    # TODO: real parsing; stub a metrics snapshot so offers can proceed
    metrics = {"avg_monthly_revenue": 80000, "avg_daily_balance_3m": 12000, "total_nsf_3m": 1, "total_days_negative_3m": 2}
    snap = MetricsSnapshot(deal_id=deal_id, source="statements", payload=metrics)
    db.add(snap)
    db.add(Event(tenant_id=tenant_id, merchant_id=merchant_id, deal_id=deal_id, type="metrics.ready", data=metrics))
    db.commit()
    resp = {"ok": True, "documents": stored, "metrics": metrics}
    await store_idempotent(request, resp)
    return resp

5) SMS consent, sender, and STOP webhook (rate-limited)

Create alembic/versions/uwizard_consents.py (set down_revision to uwizard_documents_s3):

from alembic import op
import sqlalchemy as sa

revision = "uwizard_consents"
down_revision = "uwizard_documents_s3"
branch_labels = None
depends_on = None

def upgrade():
    op.create_table(
        "consents",
        sa.Column("id", sa.String(), primary_key=True),
        sa.Column("merchant_id", sa.String(), nullable=True),
        sa.Column("phone", sa.String(), nullable=False),
        sa.Column("channel", sa.String(), nullable=False),  # "sms"
        sa.Column("status", sa.String(), nullable=False),   # "opt_in" | "opt_out"
        sa.Column("created_at", sa.DateTime(), server_default=sa.func.now(), nullable=False),
        sa.Column("updated_at", sa.DateTime(), server_default=sa.func.now(), onupdate=sa.func.now(), nullable=False),
    )
    op.create_index("ix_consents_phone", "consents", ["phone"], unique=True)

def downgrade():
    op.drop_index("ix_consents_phone", table_name="consents")
    op.drop_table("consents")


Create server/routes/sms.py:

from fastapi import APIRouter, Depends, Header, HTTPException, Request
from pydantic import BaseModel
from sqlalchemy.orm import Session
from typing import List, Optional
from ..db import get_db
from ..models import Consent, Event, Merchant
from ..core.idempotency import capture_body, require_idempotency, store_idempotent
from ..core.config import get_settings
from redis.asyncio import from_url as redis_from_url
import re, uuid, time, httpx

S = get_settings()
R = redis_from_url(S.REDIS_URL, encoding="utf-8", decode_responses=True)
router = APIRouter(prefix="/api/sms/cherry", tags=["sms"])

class SMSMessage(BaseModel):
    to: str
    body: str
    merchant_id: Optional[str] = None

class SMSPayload(BaseModel):
    campaignName: str
    messages: List[SMSMessage]

FOOTER = " Reply STOP to opt out."
PHONE_RE = re.compile(r"^\+?[1-9]\d{7,14}$")

async def rate_limit(tenant_id: str, count: int, limit: int = 2000, window_sec: int = 60):
    key = f"rt:sms:{tenant_id}"
    now = int(time.time())
    await R.zremrangebyscore(key, 0, now - window_sec)
    await R.zadd(key, {str(uuid.uuid4()): now})
    await R.expire(key, window_sec + 5)
    size = await R.zcard(key)
    if int(size) + count > limit:
        raise HTTPException(429, "Rate limit exceeded")

@router.post("/send", dependencies=[Depends(capture_body)])
async def send_sms(request: Request, payload: SMSPayload, tenant_id=Depends(require_idempotency), db: Session = Depends(get_db)):
    if getattr(request.state, "idem_cached", None):
        return request.state.idem_cached
    await rate_limit(tenant_id, len(payload.messages))
    queued = 0
    out = []
    for m in payload.messages:
        if not PHONE_RE.match(m.to): 
            continue
        c = db.query(Consent).filter(Consent.phone == m.to, Consent.channel == "sms").first()
        if c and c.status == "opt_out":
            continue
        body = m.body if "stop to opt out" in m.body.lower() else m.body + FOOTER
        out.append({"to": m.to, "body": body})
        db.add(Event(tenant_id=tenant_id, merchant_id=m.merchant_id, deal_id=None, type="sms.queued", data={"to": m.to, "campaign": payload.campaignName}))
        queued += 1
    db.commit()

    # TODO: call provider or internal relay here
    # async with httpx.AsyncClient(timeout=30) as client:
    #     await client.post("https://cherry.example/send", headers={"Authorization": f"Bearer {S.CHERRY_API_KEY}"}, json={"messages": out})

    resp = {"campaign": payload.campaignName, "queued": queued}
    await store_idempotent(request, resp)
    return resp

@router.post("/webhook")
async def webhook(req: Request, db: Session = Depends(get_db)):
    body = await req.json()
    # Normalize expected inbound payload: {"type":"inbound","from":"+19735550188","text":"STOP"}
    if (body.get("type") == "inbound") and str(body.get("text", "")).strip().upper() == "STOP":
        phone = body.get("from")
        c = db.query(Consent).filter(Consent.phone == phone, Consent.channel == "sms").first()
        if c: c.status = "opt_out"
        else: db.add(Consent(phone=phone, channel="sms", status="opt_out"))
        m = db.query(Merchant).filter(Merchant.phone == phone).first()
        db.add(Event(tenant_id=None, merchant_id=getattr(m, "id", None), deal_id=None, type="sms.stop", data={"from": phone}))
        db.commit()
    return {"ok": True}


Wire router in server/main.py:

from server.routes import sms as sms_routes
app.include_router(sms_routes.router)

6) Migrate & run

Run alembic:

alembic upgrade head


Start FastAPI (Replit run command). Ensure env vars exist.

7) Smoke tests (copy/paste and set MID/DID as you go)
# Start or reuse deal
curl -s -X POST http://localhost:8000/api/deals/start \
  -H "Content-Type: application/json" -H "X-Tenant-ID:T1" -H "Idempotency-Key:k1" \
  -d '{"merchant_hint":{"phone":"+19735550188","legal_name":"Maple Deli LLC"},"create_if_missing":true}'

# Use returned IDs
MID="<MID>"; DID="<DID>"

# Intake answer (ask-only loop)
curl -s -X POST http://localhost:8000/api/intake/answer \
  -H "Content-Type: application/json" -H "X-Tenant-ID:T1" -H "Idempotency-Key:k2" \
  -d "{\"merchant_id\":\"$MID\",\"deal_id\":\"$DID\",\"source\":\"intake\",\"answers\":[{\"field_id\":\"owner.ssn_last4\",\"value\":\"1234\"}]}"

# Upload exactly 3 PDFs
curl -s -X POST "http://localhost:8000/api/documents/bank/upload?merchant_id=$MID&deal_id=$DID" \
  -F "files=@jun.pdf" -F "files=@jul.pdf" -F "files=@aug.pdf" \
  -H "X-Tenant-ID:T1" -H "Idempotency-Key:k3"

# Generate offers
curl -s -X POST "http://localhost:8000/api/deals/$DID/offers" -H "Content-Type: application/json" \
  -H "X-Tenant-ID:T1" -H "Idempotency-Key:k4" -d "{}"

# Accept one offer
curl -s -X POST "http://localhost:8000/api/deals/$DID/accept" \
  -H "Content-Type: application/json" -d '<OFFER_JSON>'

# Background checks (flags only)
curl -s -X POST "http://localhost:8000/api/background/run?merchant_id=$MID&deal_id=$DID" \
  -H "X-Tenant-ID:T1" -H "Idempotency-Key:k5"

# Send for signature (should block unless background OK; force=true overrides)
curl -s -X POST "http://localhost:8000/api/sign/send?deal_id=$DID&recipient_email=owner@example.com&force=false" \
  -H "X-Tenant-ID:T1" -H "Idempotency-Key:k6"

# SMS send (rate-limited + STOP footer + idempotent)
curl -s -X POST http://localhost:8000/api/sms/cherry/send \
  -H "Content-Type: application/json" -H "X-Tenant-ID:T1" -H "Idempotency-Key:k7" \
  -d '{"campaignName":"Pilot","messages":[{"to":"+19735550188","body":"Hi from UW Wizard","merchant_id":"'$MID'"}]}'


Acceptance criteria

Events for metrics/background/sms show a real deal_id column populated.

Replaying any POST with the same Idempotency-Key returns the cached result (no dup rows).

Upload rejects non-PDFs and files > 12MB; exactly 3 PDFs required.

With MOCK_MODE=true, PDFs are saved under ./data/uploads and the app still works.

SMS send returns queued count; inbound /webhook with "STOP" sets/updates consent and writes an sms.stop event.