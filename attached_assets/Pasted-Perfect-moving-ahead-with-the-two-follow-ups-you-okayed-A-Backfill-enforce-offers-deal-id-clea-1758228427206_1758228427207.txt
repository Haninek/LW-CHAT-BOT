Perfect—moving ahead with the two follow-ups you okayed:

A. Backfill & enforce offers.deal_id (clean migration from legacy offers.merchant_id)

B. Background checks pipeline (CLEAR + NY Courts + SOS) returning flags only, tied to the deal

Below are ready-to-paste snippets. Adjust paths/imports to your repo if names differ.

A) Backfill & enforce offers.deal_id
1) Alembic migration (add FK, backfill, make non-null later)

alembic/versions/uwizard_offers_dealid_backfill.py

from alembic import op
import sqlalchemy as sa

revision = "uwizard_offers_dealid_backfill"
down_revision = "<PUT_PREV_REVISION>"
branch_labels = None
depends_on = None

def upgrade():
    with op.batch_alter_table("offers") as b:
        b.add_column(sa.Column("deal_id", sa.String(), nullable=True))
    # Optional: add index for faster joins/reads
    op.create_index("ix_offers_deal_id", "offers", ["deal_id"])

def downgrade():
    op.drop_index("ix_offers_deal_id", table_name="offers")
    with op.batch_alter_table("offers") as b:
        b.drop_column("deal_id")


Run:

alembic upgrade head

2) Backfill script (map offers → deal)

Heuristics:

If an offer is already tied to a deal_id ⇒ skip.

Else, locate the most recent deal for that merchant created on/before the offer (fallback to latest deal).

If none exist, create a new open deal for that merchant and attach.

scripts/backfill_offers_deal_id.py

import os, sys
from datetime import datetime
from sqlalchemy import create_engine, text

DB_URL = os.getenv("DATABASE_URL", "sqlite:///uwizard.db")
engine = create_engine(DB_URL)

SQL = {
"find_unlinked": """
  SELECT o.id AS offer_id, o.merchant_id, o.created_at
  FROM offers o
  WHERE (o.deal_id IS NULL OR o.deal_id = '')
""",
"find_deal_by_time": """
  SELECT d.id
  FROM deals d
  WHERE d.merchant_id = :mid
    AND d.created_at <= :o_created
  ORDER BY d.created_at DESC
  LIMIT 1
""",
"find_latest_deal": """
  SELECT d.id
  FROM deals d
  WHERE d.merchant_id = :mid
  ORDER BY d.created_at DESC
  LIMIT 1
""",
"create_deal": """
  INSERT INTO deals (id, merchant_id, status, created_at, updated_at)
  VALUES (:id, :mid, 'open', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
""",
"attach": """
  UPDATE offers SET deal_id = :did WHERE id = :oid
"""
}

def cuid():
    import uuid
    return uuid.uuid4().hex

with engine.begin() as conn:
    rows = conn.execute(text(SQL["find_unlinked"])).mappings().all()
    print(f"Found {len(rows)} offers to backfill")
    for r in rows:
        mid = r["merchant_id"]
        o_created = r["created_at"] or datetime.utcnow().isoformat()

        did = None
        row = conn.execute(text(SQL["find_deal_by_time"]), {"mid": mid, "o_created": o_created}).first()
        if row: did = row[0]
        else:
            row = conn.execute(text(SQL["find_latest_deal"]), {"mid": mid}).first()
            if row: did = row[0]

        if not did:
            did = cuid()
            conn.execute(text(SQL["create_deal"]), {"id": did, "mid": mid})

        conn.execute(text(SQL["attach"]), {"did": did, "oid": r["offer_id"]})
        print(f"Offer {r['offer_id']} -> Deal {did}")

print("Backfill complete.")


Run:

python scripts/backfill_offers_deal_id.py

3) Enforce at write time (routes)

In your offers route, ensure writes set deal_id (not merchant_id) and never create offers without a valid latest metrics_snapshot for that deal_id. You already have this in place from the prior patch; just confirm you’re not writing merchant_id anymore.

B) Background checks pipeline (flags-only)

Goal: a single endpoint you can call after an offer is accepted (or earlier if you prefer) that runs:

CLEAR (Thomson Reuters) via your connector (server-side only)

NY Courts (NYSCEF) quick name check (advisory; ToS-safe implementation depends on your data provider)

SOS ownership (state business registry) lookup by EIN/name (often semi-manual/API-by-state)

…and returns a normalized decision:

OK (no red flags)

REVIEW (flags found; human review)

DECLINE (hard stop)

Everything attaches to the deal timeline.

1) Service shim for providers

server/services/background_providers.py

from typing import Dict, Any, Tuple

# CLEAR shim — real integration must live server-side, never expose creds to FE
def run_clear(merchant: Dict[str, Any], cfg: Dict[str, Any]) -> Tuple[str, Dict[str, Any]]:
    # If no credentials configured, return manual-needed
    if not cfg or not cfg.get("api_key"):
        return "manual", {"reason": "no_clear_credentials"}
    # Pseudo-call here — replace with actual CLEAR API call
    # response = clear_client.search(merchant["legal_name"], owner=merchant.get("owner"))
    # Normalize:
    # flags = {"criminal": False, "tax_liens": False, "ucco": True, ...}
    flags = {"criminal": False, "civil": False, "bankruptcy": False, "tax_liens": False, "ucco": False}
    return "ok", flags

# NYSCEF — name-only hint, advisory
def run_nyscef(merchant: Dict[str, Any]) -> Tuple[str, Dict[str, Any]]:
    # Implement via permitted data source. Placeholder:
    return "ok", {"matches": 0}

# SOS ownership lookup (state registry)
def run_sos(merchant: Dict[str, Any]) -> Tuple[str, Dict[str, Any]]:
    # Placeholder; real impl per-state or via aggregator
    return "ok", {"owner_match": True}

def decide(clear: Tuple[str,Dict[str,Any]], court: Tuple[str,Dict[str,Any]], sos: Tuple[str,Dict[str,Any]]) -> Tuple[str, Dict[str,Any]]:
    # Merge flags -> decision
    reasons = {}
    status = "OK"
    for name, (st, data) in {"clear": clear, "nyscef": court, "sos": sos}.items():
        reasons[name] = {"status": st, "data": data}
    # If any provider returns "manual" or finds serious flags -> REVIEW
    if clear[0] == "manual": status = "REVIEW"
    if clear[1].get("criminal") or clear[1].get("bankruptcy") or clear[1].get("tax_liens"):
        status = "REVIEW"
    # Add your hard stops here if desired -> DECLINE
    return status, reasons

2) Route to run background & store flags on the deal

server/routes/background.py

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import Optional
from ..db import get_db
from ..models import Deal, Merchant, Event
from ..services.background_providers import run_clear, run_nyscef, run_sos, decide

router = APIRouter(prefix="/api/background", tags=["background"])

@router.post("/run")
def run_background(merchant_id: str, deal_id: str, db: Session = Depends(get_db)):
    deal = db.query(Deal).get(deal_id)
    if not deal or deal.merchant_id != merchant_id:
        raise HTTPException(404, "Deal or merchant not found")
    m = db.query(Merchant).get(merchant_id)
    merchant = {"legal_name": m.legal_name, "ein": m.ein, "state": getattr(m, "state", None)}

    # Load CLEAR credentials for this tenant (pseudocode)
    # cfg = get_connector_config(tenant_id=..., name="clear")
    cfg = {}

    c = run_clear(merchant, cfg)
    n = run_nyscef(merchant)
    s = run_sos(merchant)
    status, reasons = decide(c, n, s)

    db.add(Event(
        tenant_id=None, merchant_id=merchant_id, deal_id=deal_id,
        type="background.result", data={"status": status, "reasons": reasons}
    ))
    db.commit()
    return {"status": status, "reasons": reasons}

3) Offers → background → signing (guard)

In your offers acceptance flow, call the background route and gate the signer:

server/routes/sign.py (example)

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from ..db import get_db
from ..models import Deal, Event
# ... import your signer client

router = APIRouter(prefix="/api/sign", tags=["sign"])

@router.post("/send")
def send_for_signature(deal_id: str, recipient_email: str, db: Session = Depends(get_db)):
    deal = db.query(Deal).get(deal_id)
    if not deal: raise HTTPException(404, "Deal not found")

    # Ensure background is OK or explicitly override
    bg_event = db.execute("""
      SELECT data FROM events
      WHERE deal_id = :did AND type = 'background.result'
      ORDER BY created_at DESC LIMIT 1
    """, {"did": deal_id}).first()
    if not bg_event:
        raise HTTPException(400, "Background check missing")
    status = (bg_event[0] or {}).get("status")
    if status != "OK":
        raise HTTPException(400, f"Background not OK (status: {status})")

    # TODO: call DocuSign/DropboxSign using deal data
    # signer.send_contract(...)
    db.add(Event(tenant_id=None, merchant_id=deal.merchant_id, deal_id=deal_id, type="sign.sent", data={"to": recipient_email}))
    db.commit()
    return {"ok": True}


Admin override: add an optional force=true query param if you want the ability to send despite a REVIEW decision.

C) Quick API smoke tests
# 1) Resolve merchant (should return found/new + open_deal if any)
curl -s "http://localhost:8000/api/merchants/resolve?phone=9735550188"

# 2) Start or reuse open deal
curl -s -X POST http://localhost:8000/api/deals/start \
  -H "Content-Type: application/json" -H "X-Tenant-ID:T1" -H "Idempotency-Key:idem1" \
  -d '{"merchant_hint":{"phone":"9735550188","legal_name":"Maple Deli LLC"},"create_if_missing":true}'

# 3) Upload three statements
curl -s -X POST "http://localhost:8000/api/documents/bank/upload?merchant_id=<MID>&deal_id=<DID>" \
  -F "files=@/path/jun.pdf" -F "files=@/path/jul.pdf" -F "files=@/path/aug.pdf"

# 4) Generate offers (guardrails enforced)
curl -s -X POST "http://localhost:8000/api/deals/<DID>/offers" -H "Content-Type: application/json" -d "{}"

# 5) Run background (flags-only)
curl -s -X POST "http://localhost:8000/api/background/run?merchant_id=<MID>&deal_id=<DID>"

# 6) Send for signature (requires background OK)
curl -s -X POST "http://localhost:8000/api/sign/send?deal_id=<DID>&recipient_email=owner@example.com"

D) Frontend note (tiny wiring)

After offer accept, call /api/background/run and gate the Send Contract button until status is OK (or admin override toggled).

In the chat, once /api/intake/answer returns missing: [], present the Docs step, then Generate Offers, then Run Background, then Send for Signature.