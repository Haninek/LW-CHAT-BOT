Replit Build Brief — Standalone LendWizely Chatbot App (Full-Stack)

Why this brief: The current prototype is missing critical pieces (Connectors page, Chat UI, DB recognition of existing merchants). Build a single Replit project that runs entirely on its own and lets me test the full flow.

0) Requirements summary

Full-stack in one Replit: FastAPI backend + SQLite DB + React (Vite+TS+Tailwind) frontend.

A Connectors admin page to add:

DocuSign/Dropbox Sign (contracts),

CLEAR (background),

Plaid (bank link),

Cherry SMS (blast).

Store connector configs encrypted at rest. Include Validate buttons.

A Chatbot page (human tone) that:

Detects existing merchants from DB (by token or phone/email) and only asks what’s missing/expired,

Lets user upload exactly 3 PDFs or connect Plaid,

Shows 3 offers (rules-driven factor/buy rates),

On accept, runs background check (CLEAR stub or live if keys),

Sends contract (DocuSign/Dropbox Sign) after OK.

A Merchants page to view/search/import CSV and open a chat for any merchant.

Works standalone (with “mock mode” for Plaid/CLEAR/Sign), but also uses live APIs if keys are set.

1) Tech stack & layout

Monorepo layout

/server   # FastAPI + SQLite + SQLAlchemy + cryptography + httpx
/web      # Vite + React + TypeScript + Tailwind + Zustand + React Router


Run mode

Dev: run both servers (FastAPI on $PORT or 8000; Vite on 5173).

Prod preview: build React and serve /web/dist via FastAPI static mount.

2) Backend (FastAPI) — endpoints & behavior
2.1 Config & security

.env:

DATABASE_URL=sqlite:///./data.db
ENCRYPTION_KEY=<Fernet 32-byte base64>     # required
API_KEY_PARTNER=dev_key                    # protects write endpoints
MOCK_MODE=true                             # if true, Plaid/CLEAR/Sign use stubs


Middleware: JSON logging (redact secrets), rate limit, body size limit, Idempotency-Key on POST.

2.2 Models (SQLite via SQLAlchemy)

Merchant(id, legal_name, dba, phone, email, ein, address, city, state, zip, status, updated_at)

FieldState(merchant_id, field_id, value, source, last_verified_at, confidence)

Connector(name unique, encrypted_config, updated_at) ← secrets encrypted (Fernet)

Intake(merchant_id, status, created_at)

Offer(merchant_id, payload_json, status, created_at)

BackgroundJob(id, merchant_id, status, result_json, created_at)

Agreement(id, merchant_id, provider, status, envelope_id, created_at, completed_at)

Event(id, type, merchant_id, data_json, created_at)

2.3 Connectors API (must exist)

POST /api/connectors → save/update {name, config} encrypted

GET /api/connectors → list names + updated_at

GET /api/connectors/{name} → masked config (keys only); ?reveal=true (dev only)

POST /api/connectors/validate → structure checks + optional live ping (Cherry/Docusign/Dropbox/CLEAR); Plaid returns TODO note in mock mode

2.4 Merchants & Intake

GET /api/merchants (search by phone/email/name), POST /api/merchants/import-csv (columns: name, phone, email, ein, address, city, state, zip)

GET /api/merchants/resolve?token=&phone=&email=

If token present, decode → fetch merchant

Else fuzzy match phone/email; return merchant with per-field status (value + last_verified_at)

POST /api/intake/start {merchant_id, campaign?} → returns intake_id

POST /api/intake/answer {merchant_id, field_id, value} → writes FieldState (source="intake", updates last_verified_at)

2.5 Documents & Metrics

POST /api/bank/parse (multipart) → must require exactly 3 PDFs

If MOCK_MODE=true, return deterministic sample metrics

Else do a simple PDF text parse to compute: avg_monthly_revenue, avg_daily_balance_3m, total_nsf_3m, total_days_negative_3m

POST /api/plaid/link-token (mock when MOCK_MODE=true), /api/plaid/exchange (stub), /api/plaid/metrics (derive metrics)

2.6 Offers

POST /api/offers → input metrics + overrides (tiers, caps, buy_rate) → return up to 3 offers

Deterministic math, round to nearest $100, add expected_margin if buy_rate present

Optional short rationale (mock when no OpenAI key)

2.7 Background (CLEAR)

POST /api/background/check {merchant_id, person:{first,last,dob,ssn4}} → create job → async run (mock/real) → webhook event background.completed

GET /api/background/jobs/{id} → status/result (decision: OK|Review|Decline, notes[])

2.8 Contracts (DocuSign/Dropbox Sign)

POST /api/contracts/upload (optional) → store a fallback PDF template in /data/contracts/default.pdf

POST /api/sign/send {merchant_id, offer_id} → if DocuSign/Dropbox connector exists, use provider; else send local upload fallback; record envelope_id

POST /api/sign/webhook → mark Agreement completed; emit event

2.9 Events & Health

GET /api/events?merchant_id= → latest timeline

GET /healthz → OK

3) Frontend (React + TS + Tailwind) — pages
3.1 Navigation

Dashboard · Chat · Merchants · Connectors · Offers Lab · Background · Sign · Settings

3.2 Dashboard

Shows API health, counts (merchants, connectors), latest events, “Seed demo data” button.

3.3 Chat (required)

Looks human (friendly tone, concise, one emoji occasionally).

Left: conversation; Right: Profile panel (shows known fields and freshness).

“Open Chat” supports:

New merchant (blank) or Existing (via token/lookup).

Ask-only-what’s-missing: for required fields, if value missing → ask; if expired → confirm; else skip.

Inputs for EIN(9), SSN last-4, phone, email (validators).

Docs step: Upload exactly 3 PDFs → calls /api/bank/parse; or Connect Plaid.

“Generate offers” → calls /api/offers with admin overrides (factor/buy rates/caps).

Accept offer → starts background → on OK → send contract; show statuses inline.

3.4 Merchants

Table with search + import CSV. Row action “Chat” opens Chat page for that merchant.

3.5 Connectors (required)

Cards for Plaid, Cherry SMS, DocuSign, Dropbox Sign, CLEAR.

Each card has inputs for keys, Save (POST /api/connectors), Validate (POST /api/connectors/validate with optional “Live ping” toggle).

Never display secrets; mask keys.

3.6 Offers Lab

Editor for tiers/caps/buy_rate (persist to LocalStorage).

Button runs local preview math and server (/api/offers) side-by-side.

3.7 Background

Form to start a check; job status poller; renders decision/notes.

3.8 Sign

Form to send a contract for a chosen merchant & offer; shows envelope status and events.

3.9 Settings

API Base, API Key (Authorization header), toggle Idempotency-Key on POSTs. Persist to LocalStorage.

4) UX rules to implement

Ask-only-what’s-missing: show at most 2 prompts at a time; confirmations are “Yes / Change”.

Auto-append “Reply STOP to opt out.” to any SMS preview (compliance).

Clear errors for: not 3 PDFs, invalid EIN/SSN4/email/phone.

Persona controls: friendly/pro/concise toggle changes microcopy.

5) Seed data (so it recognizes existing merchants)

On first run, create:

Two merchants (one existing, one new). Existing has address/phone/email filled, owner DOB/SSN4 missing → proves “ask only what’s missing.”

Default offer overrides tiers.

A fake campaign link token for the existing merchant that Chat can use to pre-load them.

6) Acceptance Criteria (must pass)

Connectors page is present and lets me save & validate all five providers (masked view), even in MOCK_MODE.

Chat page exists; I can:

Open existing merchant and see it skip known fields, confirm stale, and ask only missing.

Upload exactly 3 PDFs or choose Plaid → metrics appear.

Click Generate offers and see up to 3 offers (fees/terms) with my overrides applied.

Accept an offer → background job runs → on OK, I can Send contract; statuses update.

Merchants page: search, import CSV, and “Chat” action works.

App runs standalone on Replit without external keys (MOCK_MODE), and uses real APIs when keys are provided.

Secrets are encrypted at rest on the server; responses are masked; logs do not print secrets.

7) Replit build steps

Create a new Replit project.

Add a Python (FastAPI) server under /server and a Node (Vite React+TS) app under /web.

Server deps: fastapi uvicorn[standard] pydantic SQLAlchemy httpx python-multipart cryptography

Web deps: react react-dom react-router-dom zustand tailwindcss postcss autoprefixer uuid

Generate a Fernet key and put in .env (ENCRYPTION_KEY=...).

Implement endpoints exactly as in Sections 2.3–2.9.

Build the frontend pages in Section 3; wire to the APIs; add LocalStorage for settings and overrides.

Seed DB and LocalStorage on first boot (Section 5).

Run both servers in dev; for preview, serve /web/dist via FastAPI.

Run command suggestion (dev):

Start FastAPI on $PORT and Vite on 5173 using a small runner script (or concurrently).

Or serve built assets via FastAPI for a single-port preview.

8) Test commands (after boot)
# Health
curl $HOST/healthz

# Save a connector (encrypted at rest)
curl -X POST $HOST/api/connectors -H "Content-Type: application/json" \
  -d '{"name":"docusign","config":{"token":"abc","account_id":"123","base":"https://demo.docusign.net"}}'

# Validate connector (structure only)
curl -X POST $HOST/api/connectors/validate -H "Content-Type: application/json" \
  -d '{"name":"docusign","live":false}'

# Resolve existing merchant by email
curl "$HOST/api/merchants/resolve?email=ava@mapledeli.com"

# Intake: answer a field
curl -X POST $HOST/api/intake/answer -H "Content-Type: application/json" \
  -d '{"merchant_id":"m1","field_id":"owner.ssn_last4","value":"1234"}'

# Upload exactly 3 PDFs and get metrics
curl -X POST $HOST/api/bank/parse -F "files=@Jan.pdf" -F "files=@Feb.pdf" -F "files=@Mar.pdf"

# Generate offers with overrides
curl -X POST $HOST/api/offers -H "Content-Type: application/json" \
  -d '{"avg_monthly_revenue":80000,"avg_daily_balance_3m":12000,"total_nsf_3m":1,"total_days_negative_3m":2,
       "overrides":{"tiers":[{"factor":0.6,"fee":1.25,"term_days":120,"buy_rate":1.18}]}}'

Notes for the agent

Do not skip the Connectors and Chat pages. They are required for this delivery.

Implement MOCK_MODE so I can test everything without live keys, but enable real calls if keys exist.

Keep the chatbot copy warm and human, not robotic.

Use ask-only-what’s-missing logic with max 2 prompts at a time.

Make the app usable as a standalone demo first; integration hooks can come after.

If you want, I can also give you a one-liner message you can paste to the Replit agent like:
“Build the project exactly per the ‘Standalone LendWizely Chatbot App’ brief above.”

You said:
each company should be able to map out their fields easily so that it can api their crm with the chat bot and the chatbot can work its magic. its pretty much an automated operations tool and underwriter for them. 
ChatGPT said:
Thought for 39s

Awesome—here’s a copy-paste Replit Build Brief that tells the agent exactly how to add a Field Mapping + CRM API Bridge so any company can plug in their CRM, map fields visually, and let the chatbot automate ops + underwriting.

Replit Build Brief — “Field Mapping + CRM Bridge” (Standalone, Multi-tenant)

Goal: Build a standalone full-stack app (FastAPI + React/TS) that lets each company (tenant) map their CRM fields → the bot’s canonical schema with a drag-and-drop UI, test it, publish it, and run the whole funding workflow. The bot must recognize existing merchants from CRM data and ask only what’s missing/expired.

0) Tech & layout
/server  (FastAPI, SQLite, SQLAlchemy, httpx, cryptography)
  .env: DATABASE_URL, ENCRYPTION_KEY, API_KEY_PARTNER, MOCK_MODE=true
/web     (Vite + React + TypeScript + Tailwind + Zustand + React Router)


Dev: run both servers. Prod preview: build React and serve via FastAPI static mount.

1) Canonical schema (what the bot understands)

Create a field catalog (JSON/DB) the bot uses everywhere. Examples:

Business

business.legal_name (string, required, expiresDays=365)

business.dba (string, optional)

business.address|city|state|zip (strings, required, expiresDays=365)

business.ein (string, required, validator=ein9)

business.start_date (date, optional)

business.website (string, optional)

Owner

owner.first|last (string, required)

owner.dob (date, required)

owner.ssn_last4 (string, required, pii, validator=ssn4)

Contact

contact.phone (string, required, validator=phone10, expiresDays=365)

contact.email (string, required, validator=email, expiresDays=365)

Store each value with: { value, source, last_verified_at, confidence }.

2) Mapping architecture (multi-tenant)

DB tables

tenant(id, name)

connector(tenant_id, name, encrypted_config, updated_at) ← Fernet encryption

mapping(tenant_id, id, name, version, status: draft|active, spec_json, created_at)

merchant(id, tenant_id, external_id?, legal_name, phone, email, … minimal denorm for search)

field_state(merchant_id, field_id, value, source, last_verified_at, confidence)

(existing) intake / metrics / offers / background / agreements / events

Flow

Admin connects CRM (Salesforce/HubSpot/Zoho/Pipedrive/CSV) as a connector.

Admin opens Mapping Studio → loads a sample CRM record (mock if needed).

Admin maps CRM fields → canonical fields (drag/drop + transforms).

Click Test → see preview of normalized record + “missing/expired” summary.

Click Publish → mapping becomes active for tenant.

Incoming CRM webhooks (or scheduled fetch) run the mapping and upsert merchants.
Bot now recognizes existing merchants and asks only what’s missing.

3) Mapping DSL (spec)

Create a JSON DSL the server executes. Keep it simple and safe.

{
  "version": 1,
  "source": "salesforce",                   // or hubspot|zoho|csv|custom
  "id_path": "Id",                          // how to get external_id
  "fieldMap": {
    "business.legal_name": { "path": "Account.Name", "xform": "trim" },
    "business.address":    { "path": "Account.BillingStreet", "xform": "trim" },
    "business.city":       { "path": "Account.BillingCity" },
    "business.state":      { "path": "Account.BillingState" },
    "business.zip":        { "path": "Account.BillingPostalCode", "xform": "zip5" },
    "business.ein":        { "path": "Account.Tax_ID__c", "xform": "ein9" },
    "owner.first":         { "path": "PrimaryContact.FirstName", "xform": "ucfirst" },
    "owner.last":          { "path": "PrimaryContact.LastName",  "xform": "ucfirst" },
    "contact.phone":       { "path": "PrimaryContact.Phone",     "xform": "phone10" },
    "contact.email":       { "path": "PrimaryContact.Email",     "xform": "lower" }
  },
  "defaults": {
    "business.state": "NY"
  },
  "postRules": [
    { "if": { "missingAny": ["business.ein"] }, "set": { "confidence": 0.7 } }
  ]
}


Supported xforms (built-ins)

trim, lower, upper, ucfirst, zip5

ein9 (keep digits; must be 9)

phone10 (digits only; must be 10)

email (validate format)

date (parse YYYY-MM-DD or common formats)

last4 (take last 4 digits)

coalesce(a,b,...), join(sep, a, b), enumMap({crmVal:canonVal,...})

Evaluator (server)

Input: { tenant_id, mapping_spec, crm_record }

Output: { external_id, fields: Record<fieldId, FieldStatus> }

Any field not found stays unset (so chatbot will ask later).

4) Webhooks & fetchers (CRM ingestion)

Implement one generic ingestion endpoint (others can be added later):

POST /api/ingest/crm (tenant auth required)
Body: { source: "salesforce"|"hubspot"|"zoho"|"pipedrive"|"csv", record: {...} }
Steps:

Load tenant’s active mapping for that source.

Evaluate mapping → {external_id, fields}.

Upsert merchant (by tenant_id + external_id or fallback phone/email).

For each field, write/update field_state with source="crm" and last_verified_at=now.

Return normalized snapshot + “missing/expired” list.

Add easy stubs for:

Salesforce streaming/webhook

HubSpot CRM v3 webhook

Zoho, Pipedrive, CSV upload

(When MOCK_MODE=true, accept payloads without validating tokens.)

5) Frontend — Mapping Studio (required pages)
A) Connectors (Admin)

Cards for Salesforce, HubSpot, Zoho, Pipedrive, CSV + existing (Plaid, Cherry, DocuSign, Dropbox, CLEAR).

Each card: fields for keys/URLs → Save (POST /api/connectors) → Validate (POST /api/connectors/validate).

B) Mapping Studio (Admin)

Tabs:

Source: pick CRM and load a sample record (paste JSON or fetch from connector).

Map: two columns (CRM fields on left; Canonical on right).

Drag CRM field onto a Canonical field.

Choose a transform (dropdown).

Show live preview of transformed value + validity (green/red).

Defaults & Rules: set defaults and postRules (simple JSON editor with schema).

Test: shows normalized output + “missing/expired” summary and what the chatbot will ask next.

Publish: saves version and marks it active.

Persist per-tenant; show version history with rollback.

C) Merchants

Search/list; Import CSV (maps columns by header names using the same DSL evaluator for CSV record).

Row action “Open Chat”.

D) Chat (uses mapping outcomes)

If opened with merchant param (id or token), prefill fields from DB and run ask-only-what’s-missing (max 2 prompts at a time).

Friendly microcopy, validators (EIN, SSN4, phone, email), confirm stale fields.

6) Server endpoints to add

Mappings

POST /api/mappings → create draft (tenant-scoped)

PUT /api/mappings/{id} → update draft

POST /api/mappings/{id}/test → input sample record → return normalized + issues

POST /api/mappings/{id}/publish → set active, version++

GET /api/mappings/active?source= → fetch active mapping for source

Ingestion

POST /api/ingest/crm → upsert merchant via active mapping (Section 4)

Merchants

GET /api/merchants → search (name/phone/email/external_id)

GET /api/merchants/{id} → detail (with field_state)

POST /api/merchants/import-csv → parse & ingest each row using source="csv"

Auth

Protect write routes with Authorization: Bearer $API_KEY_PARTNER

Multi-tenant via X-Tenant-ID header

7) Ask-only-what’s-missing (server + UI)

Server helper

def missing_and_expired(field_defs, field_states, now):
    missing, confirm = [], []
    for f in field_defs:
        st = field_states.get(f.id)
        if not st or st.get("value") in (None, ""):
            if f.required: missing.append(f.id)
            continue
        if f.expiresDays:
            last = st.get("last_verified_at")
            if last and (now - parse(last)).days > f.expiresDays:
                confirm.append(f.id)
    return missing, confirm


UI

Show at most 2 prompts at a time; confirmations are “Yes / Change”.

On answer, POST /api/intake/answer to update the field with source="intake" + new last_verified_at.

8) Sample mappings to include

Salesforce (as above)
HubSpot:

{
  "version":1,"source":"hubspot","id_path":"id",
  "fieldMap":{
    "business.legal_name":{"path":"properties.name","xform":"trim"},
    "business.address":{"path":"properties.address"},
    "business.city":{"path":"properties.city"},
    "business.state":{"path":"properties.state"},
    "business.zip":{"path":"properties.zip","xform":"zip5"},
    "contact.phone":{"path":"properties.phone","xform":"phone10"},
    "contact.email":{"path":"properties.email","xform":"lower"}
  }
}


CSV (header names):

{
  "version":1,"source":"csv","id_path":"ExternalId",
  "fieldMap":{
    "business.legal_name":{"path":"LegalName"},
    "business.ein":{"path":"EIN","xform":"ein9"},
    "contact.email":{"path":"Email","xform":"email"}
  }
}

9) Acceptance criteria (done = ✅)

Connectors page works for CRM + existing providers; configs saved encrypted; validate buttons present.

Mapping Studio loads sample JSON, lets me drag-map fields, choose transforms, test, and publish; version history present.

Ingestion (POST /api/ingest/crm) upserts merchants using active mapping; I can see normalized fields in the merchant profile.

Chat recognizes existing merchants (via id/token/lookup) and asks only missing/expired with validators.

CSV import uses the same mapping evaluator for rows.

Multi-tenant: mappings and connectors are scoped by X-Tenant-ID.

Runs in MOCK_MODE (no external keys) and switches to live if keys exist.

Secrets are masked in responses and not logged.

10) Replit run steps

Server deps: fastapi uvicorn[standard] SQLAlchemy httpx python-multipart cryptography pydantic
Web deps: react react-dom react-router-dom zustand tailwindcss postcss autoprefixer uuid
Env:

DATABASE_URL=sqlite:///./data.db
ENCRYPTION_KEY=<Fernet key>
API_KEY_PARTNER=dev_key
MOCK_MODE=true


Start (dev):

Run FastAPI on $PORT

Run Vite on 5173

Or serve built /web/dist via FastAPI for single-port preview

Notes to keep it human & useful

Tone: warm, concise, one emoji occasionally.

Always append “Reply STOP to opt out.” to any SMS previews.

Keep SSN collection to last-4 in chat; collect full only in a secure signing packet if required.