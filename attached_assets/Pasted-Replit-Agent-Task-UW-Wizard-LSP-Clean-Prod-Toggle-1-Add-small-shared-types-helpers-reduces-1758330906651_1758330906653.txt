Replit Agent Task — “UW Wizard” LSP Clean + Prod Toggle
1) Add small shared types + helpers (reduces type noise)

Create server/shared/types.py

from __future__ import annotations
from typing import Any, Dict, List, Optional, TypedDict

JSONDict = Dict[str, Any]
StrList = List[str]


Create server/shared/http.py

from __future__ import annotations
from typing import Any, Dict
from fastapi import Response
import json

def ok(payload: Dict[str, Any]) -> Response:
    return Response(content=json.dumps(payload), media_type="application/json")


You can keep returning plain dicts; this helper is just for LSP purity if you use it.

2) Standardize imports + annotations at top of each route (deals.py, offers.py, intake.py, sign.py, background.py)

At the first lines of each of these files, insert/ensure this block (keep existing specific imports too):

from __future__ import annotations
from typing import Any, Dict, List, Optional
from fastapi import APIRouter, Depends, HTTPException, Request, Header, Query, Body
from sqlalchemy.orm import Session
from server.core.database import get_db
from server.core.idempotency import capture_body, require_idempotency, store_idempotent
from server.core.auth import require_bearer, require_partner


This clears “unresolved name / type” and missing import diagnostics the LSP often flags.

3) Fix the common SQLAlchemy warning the LSP flags

Replace any of these patterns (seen commonly in offers.py, sign.py, deals.py):

deal = db.query(Deal).get(deal_id)
merchant = db.query(Merchant).get(merchant_id)


with modern SQLAlchemy:

deal = db.get(Deal, deal_id)
merchant = db.get(Merchant, merchant_id)


This removes deprecation diagnostics and helps the type checker.

4) Add explicit return types for handlers (quiets “incompatible return”)

Example edits per file:

server/routes/deals.py (apply pattern across handlers)
router = APIRouter(prefix="/api/deals", tags=["deals"], dependencies=[Depends(require_bearer)])

@router.post("/start", dependencies=[Depends(capture_body)])
async def start_deal(request: Request, db: Session = Depends(get_db),
                     tenant_id=Depends(require_idempotency)) -> Dict[str, Any]:
    if getattr(request.state, "idem_cached", None):
        return request.state.idem_cached
    # ... existing logic ...
    resp: Dict[str, Any] = {"merchant_id": merchant_id, "deal_id": deal_id, "status": "open"}
    await store_idempotent(request, resp)
    return resp

server/routes/offers.py
@router.post("/{deal_id}/offers", dependencies=[Depends(capture_body)])
async def make_offers(request: Request, deal_id: str, db: Session = Depends(get_db),
                      tenant_id=Depends(require_idempotency)) -> Dict[str, Any]:
    if getattr(request.state, "idem_cached", None):
        return request.state.idem_cached
    deal = db.get(Deal, deal_id)
    if not deal:
        raise HTTPException(404, "deal not found")
    offers = generate_offers(deal_id, db)
    if isinstance(offers, dict) and offers.get("blocked"):
        resp = {"blocked": True, "reason": offers.get("reason")}
        await store_idempotent(request, resp); return resp
    # ... persist + event ...
    resp = {"offers": offers}
    await store_idempotent(request, resp); return resp

@router.post("/{deal_id}/accept", dependencies=[Depends(capture_body)])
async def accept_offer(request: Request, deal_id: str, db: Session = Depends(get_db),
                       tenant_id=Depends(require_idempotency)) -> Dict[str, Any]:
    # ... existing logic ...
    return {"ok": True, "deal_id": deal_id, "status": "accepted"}

server/routes/intake.py

Annotate each handler like:

async def answer(request: Request, ... ) -> Dict[str, Any]:
    ...

server/routes/sign.py
async def send_for_signature(request: Request, deal_id: str, recipient_email: str, force: bool = False,
                             tenant_id=Depends(require_idempotency), db: Session = Depends(get_db)) -> Dict[str, Any]:
    ...

async def signer_webhook(request: Request, db: Session = Depends(get_db), ...) -> Dict[str, Any]:
    ...

server/routes/background.py
router = APIRouter(prefix="/api/background", tags=["background"],
                   dependencies=[Depends(require_bearer), Depends(require_partner)])

@router.post("/check", dependencies=[Depends(capture_body)])
async def check(request: Request, db: Session = Depends(get_db),
                tenant_id=Depends(require_idempotency), body: Dict[str, Any] = Body(...)) -> Dict[str, Any]:
    ...

5) (Optional) Add minimal response models to calm strict LSPs

If your LSP is still noisy, define a couple of Pydantic v2 models in each file (or a shared schemas.py):

from pydantic import BaseModel, Field
from typing import List, Any, Dict

class OfferOut(BaseModel):
    amount: float
    factor_rate: float
    term_days: int

class OffersResp(BaseModel):
    offers: List[OfferOut]


Then annotate the route:

@router.post("/{deal_id}/offers", response_model=OffersResp, dependencies=[Depends(capture_body)])
async def make_offers(... ) -> Dict[str, Any]:
    ...


(FastAPI will happily coerce your dicts; this annotation mostly helps the LSP.)

6) Prod/Stage toggle (single switch)

In Replit Secrets for staging/prod:

DEBUG=false
AUTH_OPTIONAL=false
AUTH_BEARER_TOKENS=<comma_separated_prod_tokens>
PARTNER_KEYS=<comma_separated_partner_keys>
DATABASE_URL=postgresql+psycopg://...
REDIS_URL=redis://...
MOCK_MODE=false
CORS_ORIGINS=https://uwizard.yourdomain.com,https://admin.yourdomain.com
AWS_REGION=us-east-1
AWS_ACCESS_KEY_ID=***
AWS_SECRET_ACCESS_KEY=***
S3_BUCKET=uwizard-private
DOCUSIGN_WEBHOOK_SECRET=***
DROPBOXSIGN_WEBHOOK_SECRET=***

7) Re-run quick smoke (dev)
pkill -f "uvicorn .*server\.main:app" >/dev/null 2>&1 || true
uvicorn server.main:app --host 0.0.0.0 --port 8000 --reload >/tmp/uw.log 2>&1 &
sleep 2

AUTH='-H "Authorization: Bearer dev" -H "X-Tenant-ID:T1"'
JSON='-H "Content-Type: application/json"'

RESP=$(curl -s -X POST http://localhost:8000/api/deals/start $AUTH $JSON \
  -H "Idempotency-Key:k1" \
  -d '{"merchant_hint":{"phone":"+19735550188","legal_name":"Maple Deli LLC"},"create_if_missing":true}')
MID=$(echo "$RESP" | python - <<'PY'
import sys,json;print(json.load(sys.stdin).get("merchant_id",""))
PY
); DID=$(echo "$RESP" | python - <<'PY'
import sys,json;print(json.load(sys.stdin).get("deal_id",""))
PY
)

printf '%%PDF-1.4\n1 0 obj<<>>endobj\ntrailer<<>>\n%%EOF\n' > one.pdf
cp one.pdf two.pdf; cp one.pdf three.pdf
curl -s -X POST "http://localhost:8000/api/documents/bank/upload?merchant_id=$MID&deal_id=$DID" \
  $AUTH -H "Idempotency-Key:k2" -F "files=@one.pdf" -F "files=@two.pdf" -F "files=@three.pdf"
curl -s -X POST "http://localhost:8000/api/deals/$DID/offers" $AUTH $JSON -H "Idempotency-Key:k3" -d "{}"
curl -s -X POST "http://localhost:8000/api/background/check" $AUTH $JSON \
  -H "X-Partner-Key: demo" -H "Idempotency-Key:k4" \
  -d "{\"merchant_id\":\"$MID\",\"person\":{\"first_name\":\"A\",\"last_name\":\"B\"},\"business\":{\"legal_name\":\"Maple Deli LLC\"}}"
curl -s -X POST "http://localhost:8000/api/deals/$DID/accept" $AUTH $JSON -H "Idempotency-Key:k5" -d "{}"
curl -s http://localhost:8000/api/public/deals | head

Why this clears the 26 diagnostics

Consistent import prelude removes “unresolved reference” and “missing import” warnings.

db.get(Model, id) fixes the most common SQLAlchemy deprecation/typing complaint.

Return type hints stop “implicit Any”/“incompatible return” noise.

Optional response models calm strict LSPs without changing behavior.

Prod toggle documented so you can flip auth/storage immediately when moving off Replit.

If any warning survives, paste one example diagnostic (filename + line + message) and I’ll give you the exact 2–3 line fix for that spot.