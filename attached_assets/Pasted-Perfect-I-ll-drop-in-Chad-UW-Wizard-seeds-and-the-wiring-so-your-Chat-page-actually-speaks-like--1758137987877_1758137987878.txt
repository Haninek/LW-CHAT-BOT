Perfect — I’ll drop in Chad (UW Wizard) seeds and the wiring so your Chat page actually speaks like Chad and adapts to potential vs existing clients.

Replit Agent — Do This Exactly

Create file: web/src/seeds_chad.ts

Call bootstrapChadSeeds() once in web/src/main.tsx (or App.tsx).

Update Chat page to read persona/templates/rules from LocalStorage and pick the right greeting for new vs existing.

Keep the “ask-only-what’s-missing” logic (max 2 prompts at a time).

1) web/src/seeds_chad.ts
// UW Wizard — Chad persona, templates, rules
// LocalStorage keys used below:
//   UW_PERSONA, UW_TEMPLATES, UW_RULES

export type Persona = { style: "friendly"|"professional"|"concise"; reading: "6th"|"8th"|"10th"; emoji: "low"|"med"|"high"; displayName: string; signature: string; disclaimer: string; };
export type Template = { id: string; channel: "sms"|"chat"; label: string; text: string; };
export type Condition =
  | { kind: "equals"; field: string; value: unknown }
  | { kind: "missingAny"; fields: string[] }
  | { kind: "notExpiredAll"; fields: string[] }
  | { kind: "or"; any: Condition[] }
  | { kind: "and"; all: Condition[] };
export type Action =
  | { type: "setPersona"; style: "friendly"|"professional"|"concise" }
  | { type: "message"; templateId: string }
  | { type: "ask"; fields: string[] }
  | { type: "confirm"; fields: string[] };
export type Rule = { id: string; name: string; enabled: boolean; priority: number; when: Condition; then: Action[]; };

export const personaChad: Persona = {
  style: "friendly",
  reading: "8th",
  emoji: "low",
  displayName: "Chad",
  signature: "— Chad, UW Wizard",
  disclaimer: "Reply STOP to opt out."
};

export const templatesChad: Template[] = [
  { id: "sms_outreach_potential", channel: "sms", label: "Cold/Potential Outreach",
    text: "Hi, this is Chad with {{lenderName}}. Still looking for working capital? We can review and decide fast. Start here: {{intakeLink}}. Reply STOP to opt out." },
  { id: "sms_outreach_existing", channel: "sms", label: "Existing Outreach",
    text: "Hey {{firstName}} — Chad at {{lenderName}}. Want me to refresh your options? Quick check here: {{intakeLink}}. Reply STOP to opt out." },

  { id: "chat_greeting_potential", channel: "chat", label: "Chat Greeting (Potential)",
    text: "Hey! I’m Chad. I’ll keep this quick—just a few basics so I can line up options." },
  { id: "chat_greeting_existing",  channel: "chat", label: "Chat Greeting (Existing)",
    text: "Welcome back, {{firstName}}. I’ll confirm what we have and only ask for anything missing." },

  { id: "chat_confirm_address", channel: "chat", label: "Confirm Address",
    text: "Still at {{business.address}}, {{business.city}}, {{business.state}} {{business.zip}}?" },
  { id: "chat_ask_ein", channel: "chat", label: "Ask EIN",
    text: "What’s your EIN (9 digits)? If you don’t have it handy, you can skip for now." },
  { id: "chat_ask_owner_dob", channel: "chat", label: "Ask Owner DOB",
    text: "What’s the owner’s date of birth (YYYY-MM-DD)?" },
  { id: "chat_ask_owner_ssn4", channel: "chat", label: "Ask Owner SSN4",
    text: "For identity checks, what are the last 4 of SSN?" },
  { id: "chat_docs_choice", channel: "chat", label: "Docs Choice",
    text: "Great—upload your last 3 bank statements or connect your bank securely with Plaid." },
  { id: "chat_hold_review", channel: "chat", label: "Soft Hold / Review",
    text: "Thanks for submitting. I’ll have the team review and follow up shortly." },
  { id: "chat_offer_teaser", channel: "chat", label: "Offer Teaser",
    text: "Based on recent deposits and balances, here are a few options that keep daily payments comfortable." },
  { id: "chat_accept_followup", channel: "chat", label: "Accept Follow-Up",
    text: "Nice—I'll run the background checks now. If all clear, I’ll send the contract to {{recipientEmail}}." }
];

export const rulesChad: Rule[] = [
  {
    id: "r0-set-persona-chad",
    name: "Set persona: Chad",
    enabled: true,
    priority: 1,
    when: { kind: "equals", field: "true", value: true },
    then: [ { type: "setPersona", style: "friendly" }, { type: "message", templateId: "chat_greeting_potential" } ]
  },
  {
    id: "r1-entry-potential",
    name: "Entry: Potential lead",
    enabled: true,
    priority: 5,
    when: { kind: "equals", field: "merchant.status", value: "new" },
    then: [
      { type: "message", templateId: "chat_greeting_potential" },
      { type: "ask", fields: ["business.legal_name","business.address","business.city","business.state","business.zip"] }
    ]
  },
  {
    id: "r2-entry-existing",
    name: "Entry: Existing client",
    enabled: true,
    priority: 6,
    when: { kind: "equals", field: "merchant.status", value: "existing" },
    then: [
      { type: "message", templateId: "chat_greeting_existing" },
      { type: "confirm", fields: ["business.address","business.city","business.state","business.zip","contact.phone","contact.email"] },
      { type: "ask", fields: ["business.ein","owner.dob","owner.ssn_last4"] }
    ]
  },
  {
    id: "r3-ask-only-missing",
    name: "Ask only what’s missing/expired",
    enabled: true,
    priority: 9,
    when: { kind: "missingAny", fields: ["business.ein","owner.dob","owner.ssn_last4","contact.phone","contact.email"] },
    then: [ { type: "ask", fields: ["business.ein","owner.dob","owner.ssn_last4","contact.phone","contact.email"] } ]
  },
  {
    id: "r4-docs-step",
    name: "Docs step after basics",
    enabled: true,
    priority: 12,
    when: { kind: "notExpiredAll", fields: ["business.legal_name","contact.phone","contact.email"] },
    then: [ { type: "message", templateId: "chat_docs_choice" } ]
  }
];

// One-time bootstrap: merge (don’t overwrite) if user already has content
export function bootstrapChadSeeds() {
  const merge = <T,>(key: string, add: T[], selector: (x:T)=>string) => {
    const cur = JSON.parse(localStorage.getItem(key) || "[]") as T[];
    const ids = new Set(cur.map(selector));
    const next = [...cur];
    add.forEach(a => { const id = selector(a); if (!ids.has(id)) next.push(a); });
    localStorage.setItem(key, JSON.stringify(next));
  };

  if (!localStorage.getItem("UW_PERSONA")) {
    localStorage.setItem("UW_PERSONA", JSON.stringify(personaChad));
  }
  merge<Template>("UW_TEMPLATES", templatesChad, (t)=>t.id);
  merge<Rule>("UW_RULES", rulesChad, (r)=>r.id);
}

2) Call the bootstrap once

In web/src/main.tsx (or earliest entry):

import { bootstrapChadSeeds } from "./seeds_chad";
bootstrapChadSeeds();

3) Wire the Chat page to Chad + rules

In your Chat component:

// helpers
const getPersona = () => JSON.parse(localStorage.getItem("UW_PERSONA") || "{}");
const getTemplates = () => JSON.parse(localStorage.getItem("UW_TEMPLATES") || "[]") as {id:string; text:string;}[];
const getRules = () => JSON.parse(localStorage.getItem("UW_RULES") || "[]");

const render = (tplId: string, ctx: Record<string, any>) => {
  const tpl = getTemplates().find(t => t.id === tplId);
  if (!tpl) return "";
  return tpl.text.replace(/\{\{([^}]+)\}\}/g, (_, k) => (ctx[k.trim()] ?? ""));
};

// very small evaluator: runs first enabled rule whose equals/missing/notExpired matches
function evaluateRules(context: Record<string, any>) {
  const rules = (getRules() as any[]).filter(r => r.enabled)
    .sort((a,b)=> a.priority - b.priority);
  const has = (path: string) => !!context[path]?.value || !!context[path];
  const missingAny = (fields: string[]) => fields.some(f => !has(f));
  const notExpiredAll = (fields: string[]) => true; // stub: if you track freshness, implement here

  const test = (c:any):boolean => {
    if (c.kind === "equals") return (context[c.field] ?? null) === c.value;
    if (c.kind === "missingAny") return missingAny(c.fields);
    if (c.kind === "notExpiredAll") return notExpiredAll(c.fields);
    if (c.kind === "and") return c.all.every(test);
    if (c.kind === "or")  return c.any.some(test);
    return false;
  };

  for (const r of rules) if (test(r.when)) return r.then as any[];
  return [];
}


Then in your Chat component useEffect where you load a merchant:

// assume you resolved a merchant object + status: 'new' | 'existing'
// context holds flat fields like:
//   context["merchant.status"] = 'existing'
//   context["firstName"] = 'Ava'
//   context["business.address"] = '24 Oak Ave' etc.
const persona = getPersona();
const ctx = {
  "merchant.status": merchant.status,
  firstName: merchant.firstName,
  lenderName: "UW Wizard",
  intakeLink: "https://example.com/apply",
  recipientEmail: merchant.email,
  ...merchant.fields  // if you store as flat paths → values
};

const actions = evaluateRules(ctx);
for (const a of actions) {
  if (a.type === "setPersona") {
    // (optional) set tone flags in state
  }
  if (a.type === "message") {
    addBotMsg(render(a.templateId, ctx));
  }
  if (a.type === "confirm" || a.type === "ask") {
    queuePrompts(a.fields.slice(0, 2)); // show max 2 at a time
    break;
  }
}


Input rendering tips

For confirm([...]): render each field with “Yes / Change” buttons.

For ask([...]): show inputs with validators:

EIN: /^[0-9]{9}$/

SSN last-4: /^[0-9]{4}$/

Email: simple @/. check

Phone: 10 digits

When the user answers, post to your backend (/api/intake/answer) and update ctx[field] → then call evaluateRules(ctx) again to get the next actions.

That’s it — after these three steps, UW Wizard will speak as Chad, greet potential vs existing correctly, and ask only what’s missing with friendly, human microcopy.