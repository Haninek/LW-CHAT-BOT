1) Backend: read + accept endpoints
server/routes/deals_read.py
from fastapi import APIRouter, Depends, Query, HTTPException
from sqlalchemy.orm import Session
from typing import Optional, List, Dict, Any
from datetime import datetime, timedelta
from ..db import get_db
from ..models import Deal, Merchant, FieldState, BankDocument, MetricsSnapshot, Offer, Event

router = APIRouter(prefix="/api/deals", tags=["deals.read"])

REQUIRED = [
    "business.legal_name","business.address","business.city","business.state","business.zip",
    "contact.phone","contact.email","business.ein","owner.dob","owner.ssn_last4"
]
EXPIRES = { "contact.phone":365, "contact.email":365, "business.address":365 }  # days

def compute_missing_confirm(fields: List[FieldState]):
    from datetime import datetime
    by = {f.field_id: f for f in fields}
    missing = [f for f in REQUIRED if f not in by or not str(by[f].value or "").strip()]
    confirm = []
    for fid, days in EXPIRES.items():
        st = by.get(fid)
        if st and st.last_verified_at and (datetime.utcnow() - st.last_verified_at).days > days:
            confirm.append(fid)
    return missing, confirm

@router.get("")
def list_deals(
    status: Optional[str] = Query(None, description="open|offer|accepted|signed|declined|closed"),
    q: Optional[str] = Query(None, description="search legal_name/phone/email"),
    limit: int = 50,
    db: Session = Depends(get_db),
):
    dq = db.query(Deal, Merchant).join(Merchant, Merchant.id==Deal.merchant_id)
    if status: dq = dq.filter(Deal.status==status)
    if q:
        qlike = f"%{q}%"
        dq = dq.filter(
            (Merchant.legal_name.ilike(qlike)) |
            (Merchant.phone.ilike(qlike)) |
            (Merchant.email.ilike(qlike))
        )
    dq = dq.order_by(Deal.created_at.desc()).limit(limit)
    items = []
    for d, m in dq.all():
        snap = db.query(MetricsSnapshot).filter(MetricsSnapshot.deal_id==d.id).order_by(MetricsSnapshot.created_at.desc()).first()
        bg = db.query(Event).filter(Event.deal_id==d.id, Event.type=="background.result").order_by(Event.created_at.desc()).first()
        items.append({
            "deal_id": d.id, "status": d.status, "created_at": d.created_at.isoformat(),
            "merchant": {"id": m.id, "legal_name": m.legal_name, "phone": m.phone, "email": m.email, "state": getattr(m, "state", None)},
            "metrics_summary": (snap.payload if snap else None),
            "background": (bg.data if bg else None)
        })
    return {"items": items}

@router.get("/{deal_id}")
def get_deal(deal_id: str, db: Session = Depends(get_db)):
    d = db.query(Deal).get(deal_id)
    if not d: raise HTTPException(404, "deal not found")
    m = db.query(Merchant).get(d.merchant_id)
    fields = db.query(FieldState).filter(FieldState.merchant_id==m.id).all()
    missing, confirm = compute_missing_confirm(fields)
    docs = db.query(BankDocument).filter(BankDocument.deal_id==d.id).order_by(BankDocument.created_at.asc()).all()
    snap = db.query(MetricsSnapshot).filter(MetricsSnapshot.deal_id==d.id).order_by(MetricsSnapshot.created_at.desc()).first()
    offers = db.query(Offer).filter(Offer.deal_id==d.id).order_by(Offer.created_at.desc()).all()
    events = db.query(Event).filter(Event.deal_id==d.id).order_by(Event.created_at.desc()).limit(100).all()
    bg = next((e for e in events if e.type=="background.result"), None)
    sign_sent = next((e for e in events if e.type=="sign.sent"), None)
    sign_signed = next((e for e in events if e.type=="sign.signed"), None)

    return {
        "deal": {"id": d.id, "status": d.status, "created_at": d.created_at.isoformat()},
        "merchant": {"id": m.id, "legal_name": m.legal_name, "phone": m.phone, "email": m.email, "state": getattr(m, "state", None), "ein": getattr(m, "ein", None)},
        "intake": {
            "fields": [{"field_id": f.field_id, "value": f.value, "source": f.source, "last_verified_at": f.last_verified_at.isoformat()} for f in fields],
            "missing": missing, "confirm": confirm
        },
        "documents": [{"id": bd.id, "filename": bd.filename, "parsed": bd.parsed, "month": bd.month} for bd in docs],
        "metrics": (snap.payload if snap else None),
        "offers": [o.payload for o in offers],
        "background": (bg.data if bg else None),
        "signing": {"sent": (sign_sent.data if sign_sent else None), "signed": (sign_signed.data if sign_signed else None)},
        "timeline": [{"type": e.type, "data": e.data, "at": e.created_at.isoformat()} for e in events]
    }

server/routes/deals_actions.py
from fastapi import APIRouter, Depends, HTTPException, Path, Body
from sqlalchemy.orm import Session
from ..db import get_db
from ..models import Deal, Offer, Event

router = APIRouter(prefix="/api/deals", tags=["deals.actions"])

@router.post("/{deal_id}/accept")
def accept_offer(deal_id: str = Path(...), offer: dict = Body(...), db: Session = Depends(get_db)):
    d = db.query(Deal).get(deal_id)
    if not d: raise HTTPException(404, "deal not found")
    # persist accepted offer as an Offer row (if not already saved)
    rec = Offer(deal_id=deal_id, payload=offer)
    db.add(rec)
    d.status = "accepted"
    db.add(Event(tenant_id=None, merchant_id=d.merchant_id, deal_id=deal_id, type="offer.accepted", data=offer))
    db.commit()
    return {"ok": True, "deal_status": d.status}


Wire them in your app:

# server/main.py
from server.routes import deals_read, deals_actions
app.include_router(deals_read.router)
app.include_router(deals_actions.router)

2) Frontend: Deals list + Deal detail (React + Tailwind)

Assumes you already set localStorage.API_BASE to your API base (e.g., http://localhost:8000
).

web/src/pages/DealsList.tsx
import { useEffect, useMemo, useState } from "react";

type Row = {
  deal_id: string;
  status: string;
  created_at: string;
  merchant: { id:string; legal_name:string; phone?:string; email?:string; state?:string };
  metrics_summary?: any;
  background?: any;
};

export default function DealsList(){
  const apiBase = localStorage.getItem("API_BASE") || "http://localhost:8000";
  const [rows,setRows] = useState<Row[]>([]);
  const [q,setQ] = useState("");
  const [status,setStatus] = useState("");
  const [loading,setLoading]=useState(false);

  const load = async() => {
    setLoading(true);
    const url = new URL(`${apiBase}/api/deals`);
    if (q) url.searchParams.set("q", q);
    if (status) url.searchParams.set("status", status);
    const r = await fetch(url.toString());
    const j = await r.json();
    setRows(j.items || []);
    setLoading(false);
  };

  useEffect(()=>{ load(); }, []); // initial
  useEffect(()=>{ const t = setTimeout(load, 300); return ()=>clearTimeout(t); }, [q, status]);

  return (
    <div className="max-w-7xl mx-auto p-4">
      <div className="flex items-center justify-between mb-3">
        <h1 className="text-xl font-semibold">Deals</h1>
        <div className="flex gap-2">
          <input className="rounded-xl border px-3 py-2 text-sm" placeholder="Search name/phone/email" value={q} onChange={e=>setQ(e.target.value)} />
          <select className="rounded-xl border px-3 py-2 text-sm" value={status} onChange={e=>setStatus(e.target.value)}>
            <option value="">All</option>
            <option>open</option><option>offer</option><option>accepted</option><option>signed</option><option>declined</option><option>closed</option>
          </select>
        </div>
      </div>

      <div className="rounded-2xl border bg-white overflow-hidden">
        <table className="w-full text-sm">
          <thead className="bg-gray-50">
            <tr className="text-left text-gray-600">
              <th className="px-3 py-2">Deal</th>
              <th className="px-3 py-2">Merchant</th>
              <th className="px-3 py-2">Contact</th>
              <th className="px-3 py-2">State</th>
              <th className="px-3 py-2">Status</th>
              <th className="px-3 py-2">Background</th>
              <th className="px-3 py-2">Created</th>
            </tr>
          </thead>
          <tbody>
            {rows.map(r=>(
              <tr key={r.deal_id} className="border-t hover:bg-gray-50 cursor-pointer" onClick={()=> (window.location.href = `/deals/${r.deal_id}`)}>
                <td className="px-3 py-2 text-xs text-gray-500">{r.deal_id.slice(0,8)}</td>
                <td className="px-3 py-2">{r.merchant.legal_name}</td>
                <td className="px-3 py-2 text-gray-600">{r.merchant.phone || "—"}<br/>{r.merchant.email || "—"}</td>
                <td className="px-3 py-2">{r.merchant.state || "—"}</td>
                <td className="px-3 py-2"><span className="text-xs bg-gray-100 rounded-full px-2 py-0.5">{r.status}</span></td>
                <td className="px-3 py-2 text-xs">{r.background?.status || "—"}</td>
                <td className="px-3 py-2 text-xs text-gray-500">{new Date(r.created_at).toLocaleString()}</td>
              </tr>
            ))}
            {!rows.length && !loading && <tr><td colSpan={7} className="px-3 py-8 text-center text-sm text-gray-500">No deals.</td></tr>}
          </tbody>
        </table>
      </div>
    </div>
  );
}

web/src/pages/DealDetail.tsx
import { useEffect, useMemo, useState } from "react";
import { useParams } from "react-router-dom";

export default function DealDetail(){
  const { dealId } = useParams();
  const apiBase = localStorage.getItem("API_BASE") || "http://localhost:8000";

  const [data,setData]=useState<any>(null);
  const [loading,setLoading]=useState(true);
  const [files,setFiles]=useState<File[]>([]);
  const [genLoading,setGenLoading]=useState(false);

  const load = async() => {
    setLoading(true);
    const r=await fetch(`${apiBase}/api/deals/${dealId}`);
    const j=await r.json();
    setData(j); setLoading(false);
  };
  useEffect(()=>{ load(); }, [dealId]);

  const uploadDocs = async () => {
    if (files.length !== 3) { alert("Please select exactly 3 PDFs."); return; }
    const fd = new FormData();
    files.forEach(f=> fd.append("files", f));
    const url = new URL(`${apiBase}/api/documents/bank/upload`);
    url.searchParams.set("merchant_id", data.merchant.id);
    url.searchParams.set("deal_id", data.deal.id);
    const r=await fetch(url.toString(), { method: "POST", body: fd });
    if(!r.ok){ alert("Upload failed"); return; }
    await load();
    alert("Statements uploaded and metrics computed.");
  };

  const generateOffers = async () => {
    setGenLoading(true);
    const r=await fetch(`${apiBase}/api/deals/${dealId}/offers`, { method: "POST", headers: { "Content-Type":"application/json" }, body: "{}" });
    const j=await r.json();
    setGenLoading(false);
    if (j.blocked) { alert(`Blocked: ${j.reason}`); }
    await load();
  };

  const acceptOffer = async (offer:any) => {
    const r=await fetch(`${apiBase}/api/deals/${dealId}/accept`, { method: "POST", headers: { "Content-Type":"application/json" }, body: JSON.stringify(offer) });
    if(!r.ok){ alert("Failed to accept"); return; }
    await fetch(`${apiBase}/api/background/run?merchant_id=${encodeURIComponent(data.merchant.id)}&deal_id=${encodeURIComponent(data.deal.id)}`, { method: "POST" });
    await load();
  };

  const sendForSignature = async () => {
    const email = prompt("Recipient email", data.merchant.email || "");
    if (!email) return;
    const force = confirm("Force send even if background != OK? Click OK to force.");
    const r=await fetch(`${apiBase}/api/sign/send?deal_id=${dealId}&recipient_email=${encodeURIComponent(email)}&force=${force?"true":"false"}`, { method: "POST" });
    if(!r.ok){ alert("Send failed"); return; }
    alert("Contract sent.");
    await load();
  };

  if (loading || !data) return <div className="p-4">Loading…</div>;

  const missing = data.intake?.missing || [];
  const confirm = data.intake?.confirm || [];
  const offers = data.offers || [];
  const bg = data.background;
  const signing = data.signing || {};

  return (
    <div className="max-w-7xl mx-auto p-4 space-y-4">
      {/* Header */}
      <div className="rounded-2xl border bg-white p-4">
        <div className="flex items-center justify-between">
          <div>
            <div className="text-xl font-semibold">{data.merchant.legal_name}</div>
            <div className="text-sm text-gray-600">{data.merchant.phone || "—"} · {data.merchant.email || "—"} · {data.merchant.state || "—"}</div>
          </div>
          <div><span className="text-xs bg-gray-100 rounded-full px-2 py-1">{data.deal.status}</span></div>
        </div>
      </div>

      {/* Intake */}
      <div className="rounded-2xl border bg-white p-4">
        <div className="text-sm font-medium mb-2">Intake state</div>
        <div className="flex flex-wrap gap-2 text-xs">
          {missing.map((f:string)=><span key={f} className="bg-red-100 px-2 py-1 rounded-full">{f} missing</span>)}
          {confirm.map((f:string)=><span key={f} className="bg-yellow-100 px-2 py-1 rounded-full">{f} confirm</span>)}
          {!missing.length && !confirm.length && <span className="text-gray-500 text-sm">All required fields verified.</span>}
        </div>
      </div>

      {/* Documents + Metrics */}
      <div className="grid md:grid-cols-2 gap-4">
        <div className="rounded-2xl border bg-white p-4">
          <div className="text-sm font-medium mb-2">Bank Statements</div>
          <ul className="text-sm text-gray-700 list-disc pl-5">
            {data.documents.map((d:any)=> <li key={d.id}>{d.filename} {d.parsed? "✓": ""}</li>)}
            {!data.documents?.length && <li className="text-gray-500">None</li>}
          </ul>
          <div className="mt-3">
            <input type="file" accept="application/pdf" multiple onChange={e=> setFiles(Array.from(e.target.files || []))} />
            <button className="ml-2 px-3 py-2 rounded-xl border text-sm" onClick={uploadDocs}>Upload 3 PDFs</button>
          </div>
        </div>
        <div className="rounded-2xl border bg-white p-4">
          <div className="text-sm font-medium mb-2">Metrics (latest)</div>
          <pre className="bg-gray-50 rounded p-2 text-xs overflow-auto max-h-64">{JSON.stringify(data.metrics || {}, null, 2)}</pre>
          <button className="mt-2 px-3 py-2 rounded-xl border text-sm" onClick={async()=>{
            await fetch(`${apiBase}/api/deals/${dealId}/metrics/recompute`, { method:"POST" });
            await load();
          }}>Recompute Metrics</button>
        </div>
      </div>

      {/* Offers */}
      <div className="rounded-2xl border bg-white p-4">
        <div className="flex items-center justify-between">
          <div className="text-sm font-medium">Offers</div>
          <button className="px-3 py-2 rounded-xl bg-black text-white text-sm disabled:opacity-50" disabled={genLoading} onClick={generateOffers}>{genLoading? "Generating…":"Generate Offers"}</button>
        </div>
        <div className="mt-3 grid md:grid-cols-3 gap-3">
          {offers.map((o:any, i:number)=> (
            <div key={i} className="border rounded-xl p-3 text-sm">
              <pre className="bg-gray-50 rounded p-2 text-xs overflow-auto max-h-48">{JSON.stringify(o, null, 2)}</pre>
              <button className="mt-2 w-full px-3 py-2 rounded-xl border text-sm" onClick={()=>acceptOffer(o)}>Accept this Offer</button>
            </div>
          ))}
          {!offers.length && <div className="text-sm text-gray-500">No offers yet.</div>}
        </div>
      </div>

      {/* Background & Signing */}
      <div className="grid md:grid-cols-2 gap-4">
        <div className="rounded-2xl border bg-white p-4">
          <div className="text-sm font-medium mb-2">Background</div>
          <div className="text-sm">Decision: <b>{bg?.status || "—"}</b></div>
          <pre className="mt-2 bg-gray-50 rounded p-2 text-xs overflow-auto max-h-48">{JSON.stringify(bg?.reasons || {}, null, 2)}</pre>
          <button className="mt-2 px-3 py-2 rounded-xl border text-sm" onClick={async()=>{
            await fetch(`${apiBase}/api/background/run?merchant_id=${encodeURIComponent(data.merchant.id)}&deal_id=${encodeURIComponent(data.deal.id)}`, { method: "POST" });
            await load();
          }}>Run Background</button>
        </div>
        <div className="rounded-2xl border bg-white p-4">
          <div className="text-sm font-medium mb-2">Signing</div>
          <div className="text-sm text-gray-700">Sent: {signing.sent ? "Yes" : "No"} · Signed: {signing.signed ? "Yes" : "No"}</div>
          <div className="mt-2 flex gap-2">
            <button className="px-3 py-2 rounded-xl bg-black text-white text-sm" onClick={sendForSignature}>Send Contract</button>
            <button className="px-3 py-2 rounded-xl border text-sm" onClick={()=>window.open(`/admin/background`, "_blank")}>Open Admin Review</button>
          </div>
        </div>
      </div>

      {/* Timeline */}
      <div className="rounded-2xl border bg-white p-4">
        <div className="text-sm font-medium mb-2">Timeline</div>
        <ul className="text-sm text-gray-700 space-y-1 max-h-80 overflow-auto">
          {data.timeline.map((t:any, idx:number)=> (
            <li key={idx} className="border-b pb-1">
              <span className="text-xs text-gray-500">{new Date(t.at).toLocaleString()}</span> — <b>{t.type}</b>
            </li>
          ))}
          {!data.timeline?.length && <li className="text-gray-500">No events.</li>}
        </ul>
      </div>
    </div>
  );
}

Add routes to your router/nav
// web/src/main.tsx (or your router file)
import DealsList from "./pages/DealsList";
import DealDetail from "./pages/DealDetail";

<Route path="/deals" element={<DealsList/>} />
<Route path="/deals/:dealId" element={<DealDetail/>} />

// In your navbar:
{/* <NavLink to="/deals">Deals</NavLink> */}

3) How this completes the loop

List all deals with status/background at a glance.

Detail page lets you:

see required intake gaps,

upload 3 statements and view metrics,

generate & accept offers,

run background and inspect reasons,

send contract (with “force” option in Admin),

view a timeline of events.

This makes the front end usable end-to-end today. If you want, I can also add a super-simple inline intake editor (a small form to post to /api/intake/answer) so you can resolve the “missing/confirm” chips directly from Deal Detail.