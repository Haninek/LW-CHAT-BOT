1) Admin screen: Background Review (+ Force Send)
Backend (FastAPI)
server/routes/admin.py
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import Optional, List
from ..db import get_db
from ..models import Event, Deal, Merchant

router = APIRouter(prefix="/api/admin", tags=["admin"])

@router.get("/background/review")
def list_background_reviews(
    status: Optional[str] = Query(None, description="OK|REVIEW|DECLINE"),
    limit: int = 100,
    db: Session = Depends(get_db),
):
    # latest background.result per deal
    rows = db.execute("""
      WITH latest AS (
        SELECT e.*, ROW_NUMBER() OVER (PARTITION BY e.deal_id ORDER BY e.created_at DESC) AS rn
        FROM events e WHERE e.type='background.result'
      )
      SELECT l.deal_id, l.merchant_id, l.data, d.status AS deal_status, m.legal_name, m.email, m.phone
      FROM latest l
      JOIN deals d ON d.id=l.deal_id
      JOIN merchants m ON m.id=l.merchant_id
      WHERE l.rn=1
      ORDER BY l.created_at DESC
      LIMIT :lim
    """, {"lim": limit}).mappings().all()

    out = []
    for r in rows:
        decision = (r["data"] or {}).get("status")
        if status and decision != status: 
            continue
        out.append({
            "deal_id": r["deal_id"],
            "merchant_id": r["merchant_id"],
            "legal_name": r["legal_name"],
            "contact": {"email": r["email"], "phone": r["phone"]},
            "deal_status": r["deal_status"],
            "decision": decision,
            "reasons": (r["data"] or {}).get("reasons", {})
        })
    return {"items": out}

Update sign route to allow “force send”
# server/routes/sign.py  (add force param)
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from ..db import get_db
from ..models import Deal, Event

router = APIRouter(prefix="/api/sign", tags=["sign"])

@router.post("/send")
def send_for_signature(
    deal_id: str,
    recipient_email: str,
    force: bool = Query(False),
    db: Session = Depends(get_db),
):
    deal = db.query(Deal).get(deal_id)
    if not deal: raise HTTPException(404, "Deal not found")

    if not force:
        bg = db.execute("""
          SELECT data FROM events
          WHERE deal_id=:did AND type='background.result'
          ORDER BY created_at DESC LIMIT 1
        """, {"did": deal_id}).first()
        if not bg:
            raise HTTPException(400, "Background missing; pass force=true to override")
        status = (bg[0] or {}).get("status")
        if status != "OK":
            raise HTTPException(400, f"Background not OK ({status}); pass force=true to override")

    # TODO: call DocuSign/Dropbox Sign with your template + deal data
    db.add(Event(tenant_id=None, merchant_id=deal.merchant_id, deal_id=deal_id,
                 type="sign.sent", data={"to": recipient_email, "force": force}))
    db.commit()
    return {"ok": True}

Frontend (React)
web/src/pages/AdminBackgroundReview.tsx
import { useEffect, useState } from "react";

type Item = {
  deal_id: string;
  merchant_id: string;
  legal_name: string;
  contact: { email?: string; phone?: string };
  deal_status: string;
  decision: "OK"|"REVIEW"|"DECLINE";
  reasons: any;
};

export default function AdminBackgroundReview(){
  const [items,setItems]=useState<Item[]>([]);
  const [filter,setFilter]=useState<""|"OK"|"REVIEW"|"DECLINE">("");

  const apiBase = localStorage.getItem("API_BASE") || "http://localhost:8000";

  const load = async() => {
    const url = new URL(`${apiBase}/api/admin/background/review`);
    if (filter) url.searchParams.set("status", filter);
    const r=await fetch(url.toString());
    if(r.ok) setItems((await r.json()).items);
  };

  useEffect(()=>{ load(); }, [filter]);

  const forceSend = async (deal_id:string, email?:string) => {
    const recipient = email || prompt("Recipient email?");
    if (!recipient) return;
    const res = await fetch(`${apiBase}/api/sign/send?deal_id=${deal_id}&recipient_email=${encodeURIComponent(recipient)}&force=true`, {method:"POST"});
    if(res.ok) { alert("Sent for signature (forced)."); load(); }
    else { const t=await res.text(); alert("Failed: "+t); }
  };

  return (
    <div className="max-w-6xl mx-auto p-4">
      <div className="flex items-center justify-between mb-4">
        <h1 className="text-xl font-semibold">Background Reviews</h1>
        <select className="border rounded-lg px-3 py-2 text-sm" value={filter} onChange={e=>setFilter(e.target.value as any)}>
          <option value="">All</option>
          <option value="OK">OK</option>
          <option value="REVIEW">REVIEW</option>
          <option value="DECLINE">DECLINE</option>
        </select>
      </div>
      <div className="grid gap-3">
        {items.map(it=>(
          <div key={it.deal_id} className="border rounded-xl p-3 bg-white">
            <div className="flex items-center justify-between">
              <div className="font-medium">{it.legal_name} <span className="text-xs text-gray-500">({it.deal_id.slice(0,8)})</span></div>
              <span className={`text-xs rounded-full px-2 py-0.5 ${it.decision==="OK"?"bg-green-100":it.decision==="REVIEW"?"bg-yellow-100":"bg-red-100"}`}>{it.decision}</span>
            </div>
            <div className="mt-1 text-sm text-gray-600">Deal: {it.deal_status} · Email: {it.contact.email || "—"} · Phone: {it.contact.phone || "—"}</div>
            <pre className="mt-2 bg-gray-50 p-2 rounded text-xs overflow-auto max-h-48">{JSON.stringify(it.reasons, null, 2)}</pre>
            <div className="mt-2 flex gap-2">
              <button className="px-3 py-2 rounded-lg border text-sm" onClick={()=>forceSend(it.deal_id, it.contact.email)}>Force Send Contract</button>
              <button className="px-3 py-2 rounded-lg border text-sm" onClick={()=>window.open(`/deals/${it.deal_id}`,'_blank')}>Open Deal</button>
            </div>
          </div>
        ))}
        {!items.length && <div className="text-sm text-gray-500">No items.</div>}
      </div>
    </div>
  );
}


Add a route/menu item “Admin → Background Review” that renders this page.

2) Redis + Arq worker (CLEAR, parsing, SMS queues)
Install
pip install arq redis httpx pydantic
# and run a Redis locally
docker run -d --name redis -p 6379:6379 redis:7

Worker file
worker/jobs.py
from arq import cron
from arq.connections import RedisSettings
import httpx, os, json, asyncio
from typing import List

API_BASE = os.getenv("API_BASE", "http://localhost:8000")
CHERRY_BASE = os.getenv("CHERRY_BASE")  # if calling provider directly
CHERRY_KEY = os.getenv("CHERRY_KEY")

async def parse_statements(ctx, deal_id: str):
    # call your own API to recompute metrics (keeps logic in one place)
    async with httpx.AsyncClient() as client:
        r = await client.post(f"{API_BASE}/api/deals/{deal_id}/metrics/recompute", timeout=120)
        r.raise_for_status()
    return {"ok": True}

async def run_clear(ctx, deal_id: str, merchant_id: str):
    # call your server route which wraps CLEAR & others
    async with httpx.AsyncClient() as client:
        r = await client.post(f"{API_BASE}/api/background/run", params={"deal_id": deal_id, "merchant_id": merchant_id}, timeout=60)
        r.raise_for_status()
    return {"ok": True}

async def send_sms_batch(ctx, messages: List[dict], campaign_name: str = "blast"):
    payload = {"campaignName": campaign_name, "messages": messages}
    async with httpx.AsyncClient() as client:
        r = await client.post(f"{API_BASE}/api/sms/cherry/send", json=payload, headers={"Idempotency-Key": campaign_name})
        r.raise_for_status()
    return r.json()

# Example heartbeat
async def heartbeat(ctx):
    return {"ok": True}

class WorkerSettings:
    redis_settings = RedisSettings()
    functions = [parse_statements, run_clear, send_sms_batch, heartbeat]
    cron_jobs = [cron(heartbeat, minute=0)]

Run worker
arq worker.jobs.WorkerSettings

Enqueue from FastAPI (example)
# server/routes/queue.py
from fastapi import APIRouter
from arq.connections import create_pool, RedisSettings

router = APIRouter(prefix="/api/queue", tags=["queue"])

@router.post("/parse/{deal_id}")
async def queue_parse(deal_id: str):
    redis = await create_pool(RedisSettings())
    await redis.enqueue_job("parse_statements", deal_id)
    return {"queued": True}

@router.post("/background/{deal_id}/{merchant_id}")
async def queue_background(deal_id: str, merchant_id: str):
    redis = await create_pool(RedisSettings())
    await redis.enqueue_job("run_clear", deal_id, merchant_id)
    return {"queued": True}


Include queue.router in main.py if you want these helpers.

3) Pipedrive → UW Wizard ETL (Organizations, Persons, Deals, Files)
Install
pip install httpx python-dateutil

Script
scripts/pipedrive_etl.py
import os, asyncio, httpx, time
from dateutil.parser import isoparse
from sqlalchemy import create_engine, text

PIPEDRIVE_API_TOKEN = os.getenv("PIPEDRIVE_API_TOKEN")
BASE = "https://api.pipedrive.com/v1"
DB_URL = os.getenv("DATABASE_URL", "sqlite:///uwizard.db")
TENANT_ID = os.getenv("TENANT_ID", "T1")

engine = create_engine(DB_URL)

def upsert_merchant(conn, org):
    # map fields
    legal = org.get("name") or "Unknown"
    phone = (org.get("phone") or [{}])[0].get("value") if isinstance(org.get("phone"), list) else None
    email = (org.get("email") or [{}])[0].get("value") if isinstance(org.get("email"), list) else None
    ext = str(org.get("id"))
    conn.execute(text("""
      INSERT INTO merchants(id, tenant_id, external_id, legal_name, phone, email, status, created_at, updated_at)
      VALUES (:id, :tid, :ext, :legal, :phone, :email, 'active', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
      ON CONFLICT(external_id) DO UPDATE SET legal_name=:legal, phone=:phone, email=:email, updated_at=CURRENT_TIMESTAMP
    """), {"id": f"m_{ext}", "tid": TENANT_ID, "ext": ext, "legal": legal, "phone": phone, "email": email})

def upsert_deal(conn, org_id, deal):
    did = f"d_{deal['id']}"
    mid = f"m_{org_id}"
    status = "open" if deal.get("status") in ("open","won","lost") else "open"
    conn.execute(text("""
      INSERT INTO deals(id, tenant_id, merchant_id, status, created_at, updated_at)
      VALUES (:id, :tid, :mid, :status, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
      ON CONFLICT(id) DO UPDATE SET status=:status, updated_at=CURRENT_TIMESTAMP
    """), {"id": did, "tid": TENANT_ID, "mid": mid, "status": status})
    return did

async def fetch_all(client, path):
    start = 0; res=[]
    while True:
        r = await client.get(f"{BASE}/{path}", params={"api_token": PIPEDRIVE_API_TOKEN, "start": start})
        r.raise_for_status()
        data = r.json()
        items = data.get("data") or []
        res += items
        if not data.get("additional_data",{}).get("pagination",{}).get("more_items_in_collection"): break
        start = data["additional_data"]["pagination"]["next_start"]
        time.sleep(0.2)
    return res

async def main():
    if not PIPEDRIVE_API_TOKEN: raise RuntimeError("PIPEDRIVE_API_TOKEN missing")
    async with httpx.AsyncClient(timeout=30) as client:
        orgs = await fetch_all(client, "organizations")
        deals = await fetch_all(client, "deals")
        # persons/files optional: add as needed

    # index deals by org
    by_org = {}
    for d in deals:
        oid = d.get("org_id",{}).get("value")
        if not oid: continue
        by_org.setdefault(oid, []).append(d)

    with engine.begin() as conn:
        for org in orgs:
            upsert_merchant(conn, org)
            for d in by_org.get(org["id"], []):
                did = upsert_deal(conn, org["id"], d)
                # TODO: pull attachments and insert into bank_document if they're statements

    print(f"Imported {len(orgs)} orgs and {len(deals)} deals.")

if __name__ == "__main__":
    asyncio.run(main())

Run
export PIPEDRIVE_API_TOKEN=xxxxx
export DATABASE_URL="sqlite:///uwizard.db"
export TENANT_ID="T1"
python scripts/pipedrive_etl.py


Extend with Files API to copy statement PDFs into your bank_document table (store the original file URL or download to data/docs/), then trigger metrics/recompute per deal.