Replit Build Brief — “Rules + Ask-Only-What’s-Missing” Frontend

Goal: A React + TypeScript + Tailwind SPA that lets an admin create/remove/reorder rules and test a chat-style intake that only asks for missing/expired fields. It should run standalone, but be able to call my backend if VITE_API_BASE is set.

Stack

Vite + React + TypeScript

TailwindCSS for UI

Zustand for state

React Router for pages

zod (light schema validation)

uuid (ids, Idempotency-Key)

Env (Replit “Secrets”)
VITE_API_BASE=http://localhost:8080   # optional; if absent, use mock APIs
VITE_API_KEY=replace_me               # optional; sent as Authorization: Bearer

Pages to build

Rules Studio

Create / edit / enable / disable / delete / reorder rules (drag & drop).

Visual condition builder + JSON editor (side-by-side).

Template snippets (tokenized) & Persona (tone, reading level, emoji level).

Save to LocalStorage and (if API exists) POST to /api/rules.

Intake Simulator

Toggle New vs Existing merchant.

If existing, prefill from a mock “CRM record” and only ask for fields that are missing or expired.

Show the next 1–2 prompts at a time (chat bubbles) with confirm/skip/edit UX.

“Docs step” placeholder (just a green check for now).

Display a live “Readiness” bar: Required fields satisfied → ✅ Ready for offers.

Button to “Run Rules” and show which rule fired + actions returned.

(Out of scope here: offers, background, signing. This project is only rules + intake logic.)

Data Models (must implement)
A) Field registry (what we can ask for)
type FieldId =
  | "business.legal_name" | "business.dba"
  | "business.address" | "business.city" | "business.state" | "business.zip"
  | "business.ein" | "business.start_date" | "business.website"
  | "owner.first" | "owner.last" | "owner.dob" | "owner.ssn_last4"
  | "contact.phone" | "contact.email";

type FieldDefinition = {
  id: FieldId;
  label: string;
  required: boolean;        // for initial decisioning
  pii?: boolean;            // render secure input
  expiresDays?: number;     // e.g., address 365, email 365, EIN 9999
  validator?: (s: string) => boolean;
};

B) Field status (how we track “known vs missing vs expired”)
type FieldStatus = {
  value?: string;                  // known value (if any)
  source?: "crm" | "intake" | "plaid" | "esign" | "unknown";
  lastVerifiedAt?: string;         // ISO
  confidence?: number;             // 0..1
};

C) Merchant record used by simulator
type Merchant = {
  id: string;
  status: "new" | "existing";
  fields: Record<FieldId, FieldStatus>;
};

D) Rules (admin add/remove/reorder)
type Condition =
  | { kind: "equals"; field: string; value: unknown }                      // e.g., merchant.status == "existing"
  | { kind: "missingAny"; fields: FieldId[] }                              // any field missing
  | { kind: "expiredAny"; fields: FieldId[] }                              // any field expired per registry
  | { kind: "notExpiredAll"; fields: FieldId[] }                           // all not expired
  | { kind: "and"; all: Condition[] }
  | { kind: "or"; any: Condition[] };

type Action =
  | { type: "ask"; fields: FieldId[] }             // ask for these
  | { type: "confirm"; fields: FieldId[] }         // confirm if present
  | { type: "message"; templateId: string }        // render with tokens
  | { type: "setPersona"; style: "friendly"|"professional"|"concise" };

type Rule = {
  id: string;
  name: string;
  enabled: boolean;
  priority: number;               // lower = earlier
  when: Condition;
  then: Action[];
};

E) Templates & Persona
type Persona = { style: "friendly"|"professional"|"concise"; reading: "6th"|"8th"|"10th"; emoji: "low"|"med"|"high" };
type Template = { id: string; label: string; text: string };  // tokens like {{business.legal_name}} {{owner.first}}

Core Logic (exact behavior to build)
1) “Ask-only-what’s-missing” resolver

Input: merchant, fieldRegistry, now
Output: { toAsk: FieldId[], toConfirm: FieldId[] }

Algorithm:

For each FieldDefinition.required === true:

If no value → add to toAsk.

Else if expired (now - lastVerifiedAt > expiresDays) → add to toConfirm.

Cap to max 2 prompts at a time (UX).

If merchant.status === "new" → prioritize business basics, then owner, then contact.

Return { toAsk, toConfirm }.

2) Expiration check
function isExpired(field: FieldDefinition, status?: FieldStatus, now = new Date()): boolean {
  if (!status?.lastVerifiedAt || !field.expiresDays) return false;
  const last = new Date(status.lastVerifiedAt);
  const ms = field.expiresDays * 86400000;
  return (now.getTime() - last.getTime()) > ms;
}

3) Simple rules engine

Sort rules by priority, skip disabled.

Evaluate conditions (support equals, missingAny, expiredAny, notExpiredAll, and, or).

On first match, return actions. UI uses actions to:

Add a message bubble (rendered from templateId and persona).

Present input widgets for ask and confirm.

4) Token rendering

Replace {{path.to.field}} with merchant.fields["path.to.field"].value || "".

Apply persona:

friendly: contractions, 1 emoji every few messages.

professional: no emoji, clear formal tone.

concise: short sentences.

Seeds (load on first boot)

Field registry with sensible expiresDays and required flags:

Required: business.legal_name, business.address, business.city/state/zip, business.ein, owner.first/last, owner.dob, owner.ssn_last4, contact.phone, contact.email

Expiry examples: address 365 days, email 365, phone 365, EIN no expiry, dob no expiry.

Templates:

intake_welcome: “Great to meet you! I’ll grab just the basics and keep it quick.”

confirm_address: “Still at {{business.address}}, {{business.city}}, {{business.state}} {{business.zip}}?”

ask_ein: “What’s your EIN (9 digits)? You can skip if you don’t have it handy.”

Rules (2 examples):

Existing merchant fill-gaps

{
  "id": "r-existing",
  "name": "Existing: confirm + ask missing",
  "enabled": true,
  "priority": 10,
  "when": { "kind": "equals", "field": "merchant.status", "value": "existing" },
  "then": [
    { "type": "message", "templateId": "intake_welcome" },
    { "type": "confirm", "fields": ["business.address", "contact.email", "contact.phone"] },
    { "type": "ask", "fields": ["business.ein", "owner.dob", "owner.ssn_last4"] }
  ]
}


New merchant basics first

{
  "id": "r-new",
  "name": "New: basics → owner → contact",
  "enabled": true,
  "priority": 20,
  "when": { "kind": "equals", "field": "merchant.status", "value": "new" },
  "then": [
    { "type": "message", "templateId": "intake_welcome" },
    { "type": "ask", "fields": ["business.legal_name","business.address","business.city","business.state","business.zip"] },
    { "type": "ask", "fields": ["business.ein","owner.first","owner.last","owner.dob","owner.ssn_last4"] },
    { "type": "ask", "fields": ["contact.phone","contact.email"] }
  ]
}

UI Requirements
Rules Studio

List with drag to reorder; toggle enable/disable; edit & delete.

Editor:

Left: Visual builder for one rule (conditions + actions).

Right: JSON (editable). Keep them in sync.

Templates & Persona tabs.

Save stores to LocalStorage. If VITE_API_BASE provided and /api/rules exists, show “Sync to Server” button.

Intake Simulator

Header toggle: New / Existing.

Panel: “Current data” (read-only table showing value + source + lastVerifiedAt).

Chat area:

Bot renders message from rule.

For confirm(fields): show inline Yes / Change chips.

For ask(fields): render inputs; apply validators (EIN 9 digits, last4 4 digits, email).

“Next” asks up to 2 prompts at a time; updates merchant record (source="intake", lastVerifiedAt=now).

Status bar:

Missing required fields count

“Ready for next step” when zero

Footer: “Run Rules Now” → display which rule matched + list of actions.

API Adapter (works with or without a backend)

Implement a tiny api.ts:

If VITE_API_BASE exists, send requests with optional Authorization: Bearer ${VITE_API_KEY} and Idempotency-Key: <uuid>.

Else, return mock data (e.g., “resolve merchant” returns a seeded existing record).

Endpoints (only if backend available; otherwise mocked):

GET /api/merchants/resolve?phone=&email= → returns a merchant (fields filled where known)

POST /api/rules → save rules (optional)

(No other endpoints required for this brief)

Acceptance Criteria

App runs with npm run dev on Replit.

Rules can be added, removed, enabled/disabled, and reordered; persist in LocalStorage.

Intake Simulator:

Existing merchant: prefilled values; bot confirms expired and asks only missing.

New merchant: asks in logical order until all required fields satisfied.

At most 2 prompts shown at a time.

Validators prevent bad inputs (EIN, last4, email).

“Run Rules Now” shows which rule fired and the actions returned.

Persona and templates influence the tone of the messages.

With no backend, the app still works using mock adapter; with VITE_API_BASE set, it uses real API.

Replit Steps

Create a Node.js (Vite React + TS) repl.

Install deps:

npm i react react-dom zustand react-router-dom zod uuid
npm i -D tailwindcss postcss autoprefixer
npx tailwindcss init -p


Wire Tailwind (include @tailwind base; components; utilities; in index.css and set content paths).

Scaffold folders/files per the models and pages above.

Add seeds to LocalStorage on first load.

Start with npm run dev.

If you want, I can also generate the seed JSON (rules, templates, field registry, and two merchant examples) that Replit can load on first boot.