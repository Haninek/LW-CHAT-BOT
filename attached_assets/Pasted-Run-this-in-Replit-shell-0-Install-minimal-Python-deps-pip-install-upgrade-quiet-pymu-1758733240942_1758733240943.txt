Run this in Replit shell
# --- 0. Install minimal Python deps ---
pip install --upgrade --quiet pymupdf pdfplumber openai

# --- 1. Server: parsers & snapshot metrics ---
mkdir -p server/services/parsers server/routes

# Deterministic totals extractor (no-AI first)
cat > server/services/parsers/totals_any.py <<'PY'
import re
from decimal import Decimal
from typing import Dict, Any, List, Optional

def _f(x) -> float:
    try: return float(Decimal(str(x).replace(",", "").replace("$","").strip()))
    except: return 0.0

MONEY = r"\$?\s*([0-9][\d,]*\.\d{2})\s*-?"
MONEY_RE = re.compile(MONEY)

SUMMARIES = {
    "deposits": [
        r"\bOther\s+Deposits\b.*?" + MONEY,
        r"\bDeposits\s*&\s*Credits\b.*?" + MONEY,
        r"\bTotal\s+Deposits\b.*?" + MONEY,
        r"\bTotal\s+Credits\b.*?" + MONEY,
        r"\bDeposits\b.*?" + MONEY,
    ],
    "withdrawals": [
        r"\bOther\s+Withdrawals\b.*?" + MONEY,
        r"\bWithdrawals\s*&\s*Debits\b.*?" + MONEY,
        r"\bTotal\s+Withdrawals\b.*?" + MONEY,
        r"\bTotal\s+Debits\b.*?" + MONEY,
        r"\bWithdrawals\b.*?" + MONEY,
    ],
    "beginning": [
        r"\bBeginning\s+Balance\b.*?" + MONEY,
        r"\bBalance\s+on\s+(\w+\s+\d{1,2},?\s*\d{2,4})\b.*?" + MONEY,
    ],
    "ending": [
        r"\bEnding\s+Balance\b.*?" + MONEY,
        r"\bEnding\s+Balance\s+on\s+(\w+\s+\d{1,2},?\s*\d{2,4})\b.*?" + MONEY,
        r"\bNew\s+Balance\b.*?" + MONEY,
    ],
    "deposit_count": [
        r"\bOther\s+Deposits\s+(\d+)\b",
        r"\bDeposits\s*&\s*Credits\s+(\d+)\b",
        r"\bDeposits\s+(\d+)\b",
    ],
    "withdrawal_count": [
        r"\bOther\s+Withdrawals\s+(\d+)\b",
        r"\bWithdrawals\s*&\s*Debits\s+(\d+)\b",
        r"\bWithdrawals\s+(\d+)\b",
    ],
}

def _first_amount(s: str) -> Optional[float]:
    m = MONEY_RE.search(s)
    return _f(m.group(1)) if m else None

def extract_summary_from_pages(text_pages: List[str]) -> Dict[str, Any]:
    joined = "\n".join(text_pages)
    out: Dict[str, Any] = {}
    def grab(key: str):
        for pat in SUMMARIES[key]:
            m = re.search(pat, joined, re.I|re.S)
            if m:
                amt = _first_amount(m.group(0))
                if amt is not None:
                    if key == "withdrawals": amt = -abs(amt)
                    out_key = {
                        "deposits": "total_deposits",
                        "withdrawals": "total_withdrawals",
                        "beginning": "beginning_balance",
                        "ending": "ending_balance",
                        "deposit_count": "deposit_count",
                        "withdrawal_count": "withdrawal_count",
                    }[key]
                    if out_key not in out:
                        out[out_key] = int(amt) if "count" in out_key else amt
    for k in ("deposits","withdrawals","beginning","ending","deposit_count","withdrawal_count"):
        grab(k)
    return out
PY

# OCR+regex breakout (bank-agnostic)
cat > server/services/parsers/extract_any.py <<'PY'
import os, re, json, base64
from typing import Dict, Any, List
from decimal import Decimal
import fitz  # PyMuPDF
import pdfplumber

def _to_f(v) -> float:
    try: return float(Decimal(str(v).replace(',','').replace('$','')))
    except: return 0.0

def _encode_png_b64(pg) -> str:
    pix = pg.get_pixmap(matrix=fitz.Matrix(2,2), alpha=False)
    return base64.b64encode(pix.tobytes("png")).decode("ascii")

def _pick_summary_pages(text_pages: List[str]) -> List[int]:
    idxs=[]
    for i,t in enumerate(text_pages):
        tt=t.lower()
        if any(k in tt for k in ["account summary","summary of your account","summary of activity",
                                 "deposits","withdrawals","other deposits","other withdrawals","totals"]):
            idxs.append(i)
    if not idxs:
        n=len(text_pages)
        idxs=[0]+([1] if n>1 else [])+([n-1] if n>2 else [])
    seen=set(); out=[]
    for i in idxs:
        if i not in seen:
            out.append(i); seen.add(i)
        if len(out)==3: break
    return out

CURRENCY_RE = re.compile(r"\$?\s?([0-9][\d,]*\.\d{2})-?")
AMOUNT = lambda s: _to_f(CURRENCY_RE.search(s).group(1)) if CURRENCY_RE.search(s) else None

def _sum_next_amount(text: str, anchor_pat: str, window: int = 200) -> float:
    total=0.0
    for m in re.finditer(anchor_pat, text, re.I|re.S):
        tail=text[m.end(): m.end()+window]
        a = AMOUNT(tail)
        if a is not None: total+=abs(a)
    return total

def _sum_inline(text: str, line_pat: str) -> float:
    total=0.0
    for line in text.splitlines():
        if re.search(line_pat, line, re.I):
            a=AMOUNT(line)
            if a is not None: total+=abs(a)
    return total

def _breakouts_fulltext(text: str) -> Dict[str,float]:
    out={}
    out["mobile_check_deposits"]   = _sum_inline(text, r"Mobile\s+Check\s+Deposit")
    out["deposits_from_RADOVANOVIC"] = _sum_next_amount(text, r"Electronic\s+Deposit(?:(?!\n).){0,200}?From\s+RADOVANOVIC")
    out["wire_credits"]            = _sum_next_amount(text, r"Wire\s+Credit|Incoming\s+Wire|Credit\s+Wire")
    out["loan_proceeds_credits"]   = _sum_next_amount(text, r"Loan\s+Proceeds|Loan\s+Advance|Funding\s+Proceeds|Advance\s+Credit")
    out["withdrawals_PFSINGLE_PT"] = _sum_next_amount(text, r"Electronic\s+Settlement(?:(?!\n).){0,200}?PFSINGLE|SETTLMT\s+PFSINGLE")
    out["withdrawals_Zelle"]       = _sum_next_amount(text, r"\bZelle\b")
    out["withdrawals_AMEX"]        = _sum_next_amount(text, r"To\s+AMEX|AMEX\s+EPAYMENT|AMERICAN\s+EXPRESS")
    out["withdrawals_CHASE_CC"]    = _sum_next_amount(text, r"To\s+CHASE\s+(?:CREDIT\s+CRD|CARD)|AUTOPAY\s+CHASE")
    out["withdrawals_CADENCE_BANK"]= _sum_next_amount(text, r"To\s+CADENCE\s+BANK")
    out["withdrawals_SBA_EIDL"]    = _sum_next_amount(text, r"SBA\s+EIDL|To\s+SBA")
    out["withdrawals_Nav_Technologies"] = _sum_next_amount(text, r"Nav\s+Technologies|Nav\s+Tech")
    out["bank_fees"]               = _sum_next_amount(text, r"Analysis\s+Service\s+Charge|Bank\s+Service\s+Fee|Monthly\s+Service\s+Fee")
    out["transfer_in"]             = _sum_next_amount(text, r"Transfer\s+From|Online\s+Transfer\s+From|Account\s+Transfer\s+From")
    out["transfer_out"]            = _sum_next_amount(text, r"Transfer\s+To|Online\s+Transfer\s+To|Account\s+Transfer\s+To")
    return out

def extract_daily_endings(text: str) -> List[float]:
    heads = [
        r"Date\s+Ending\s+Balance",
        r"Daily\s+Ending\s+Balance",
        r"Daily\s+Ledger\s+Balance",
        r"Daily\s+Balance",
    ]
    for h in heads:
        m = re.search(h + r".*?(?:Only\s+balances.*?|This\s+statement.*?|Page\s+\d+|\Z)", text, re.I|re.S)
        if m:
            block = m.group(0)
            vals = re.findall(r"([\d,]+\.\d{2})", block)
            if vals: return [_to_f(x) for x in vals]
    return []

def _openai_client():
    try:
        from openai import OpenAI
        key = os.getenv("OPENAI_API_KEY")
        return OpenAI(api_key=key) if key else None
    except Exception:
        return None

PROMPT = """You are reading bank statements. Extract exact MONTH TOTALS from each supplied page image.
Return strict JSON:
{"period_label": null|"Mon YYYY","beginning_balance":0.00|null,"ending_balance":0.00|null,"deposit_count":0|null,"total_deposits":0.00|null,"withdrawal_count":0|null,"total_withdrawals":0.00|null}
Use the table totals (Deposits & Credits / Other Deposits, Withdrawals & Debits / Other Withdrawals). Return ONLY JSON."""

def _llm_extract_on_pages(b64_pages: List[str]) -> Dict[str,Any]:
    client=_openai_client()
    if not client: return {}
    content=[{"type":"text","text":PROMPT}]
    for b in b64_pages:
        content.append({"type":"input_image","image_url":{"url":f"data:image/png;base64,{b}","detail":"low"}})
    try:
        resp = client.chat.completions.create(
            model=os.getenv("OPENAI_MODEL","gpt-4o-mini"),
            messages=[{"role":"user","content":content}],
            response_format={"type":"json_object"},
            temperature=0.1,
            max_tokens=400
        )
        import json
        return json.loads(resp.choices[0].message.content)
    except Exception:
        return {}

def extract_any_bank_statement(pdf_path: str) -> Dict[str,Any]:
    text_pages=[]
    with pdfplumber.open(pdf_path) as pdf:
        for pg in pdf.pages:
            text_pages.append(pg.extract_text() or "")
    doc=fitz.open(pdf_path)
    idxs=_pick_summary_pages(text_pages)
    b64s=[ _encode_png_b64(doc[i]) for i in idxs ]
    llm=_llm_extract_on_pages(b64s)
    totals = {
        "beginning_balance": _to_f(llm.get("beginning_balance")) if llm else None,
        "ending_balance": _to_f(llm.get("ending_balance")) if llm else None,
        "deposit_count": int(llm.get("deposit_count")) if llm.get("deposit_count") not in (None,"") else None,
        "total_deposits": _to_f(llm.get("total_deposits")) if llm else None,
        "withdrawal_count": int(llm.get("withdrawal_count")) if llm.get("withdrawal_count") not in (None,"") else None,
        "total_withdrawals": -abs(_to_f(llm.get("total_withdrawals"))) if llm and llm.get("total_withdrawals") not in (None,"") else None,
        "period": llm.get("period_label") if llm else None,
    }
    full_text = "\n".join(text_pages)
    brk = _breakouts_fulltext(full_text)
    daily = extract_daily_endings(full_text)
    row = { **totals, **brk,
            "min_daily_ending_balance": min(daily) if daily else None,
            "max_daily_ending_balance": max(daily) if daily else None,
            "daily_endings_full": daily }
    return row
PY

# Snapshot aggregator (your requested fields)
cat > server/services/snapshot_metrics.py <<'PY'
from typing import List, Dict, Any
from decimal import Decimal

def _f(x) -> float:
    try: return float(Decimal(str(x)))
    except: return 0.0

def compute_snapshot(months: List[Dict[str,Any]]) -> Dict[str,Any]:
    if not months:
        return {k:0 for k in [
            "avg_deposit_amount","other_advances","transfer_amount","misc_deduction",
            "number_of_deposits","negative_days","avg_daily_balance","avg_beginning_balance","avg_ending_balance"
        ]}
    dep_sum = sum(_f(m.get("total_deposits",0)) for m in months)
    dep_cnt = int(sum(_f(m.get("deposit_count",0)) for m in months))
    avg_deposit_amount = (dep_sum/dep_cnt) if dep_cnt else 0.0

    other_advances = sum(_f(m.get("wire_credits",0)) + _f(m.get("loan_proceeds_credits",0)) for m in months)
    transfer_amount = sum(_f(m.get("transfer_in",0)) + _f(m.get("transfer_out",0)) for m in months)

    known_out = ["withdrawals_PFSINGLE_PT","withdrawals_CADENCE_BANK","withdrawals_SBA_EIDL",
                 "withdrawals_AMEX","withdrawals_CHASE_CC","withdrawals_Nav_Technologies",
                 "withdrawals_Zelle","bank_fees","transfer_out"]
    total_w = sum(abs(_f(m.get("total_withdrawals",0))) for m in months)
    known_sum = sum(abs(_f(m.get(k,0))) for m in months for k in known_out)
    misc_deduction = max(0.0, total_w - known_sum)

    number_of_deposits = dep_cnt
    all_daily = []
    for m in months: all_daily.extend([_f(x) for x in (m.get("daily_endings_full") or []) if x is not None])
    negative_days = sum(1 for x in all_daily if x < 0)
    if not all_daily:
        all_daily = [(_f(m.get("beginning_balance",0)) + _f(m.get("ending_balance",0)))/2.0 for m in months]
    avg_daily_balance = (sum(all_daily)/len(all_daily)) if all_daily else 0.0

    avg_beginning_balance = sum(_f(m.get("beginning_balance",0)) for m in months)/len(months)
    avg_ending_balance = sum(_f(m.get("ending_balance",0)) for m in months)/len(months)

    return {
        "avg_deposit_amount": round(avg_deposit_amount,2),
        "other_advances": round(other_advances,2),
        "transfer_amount": round(transfer_amount,2),
        "misc_deduction": round(misc_deduction,2),
        "number_of_deposits": int(number_of_deposits),
        "negative_days": int(negative_days),
        "avg_daily_balance": round(avg_daily_balance,2),
        "avg_beginning_balance": round(avg_beginning_balance,2),
        "avg_ending_balance": round(avg_ending_balance,2),
    }
PY

# --- 2. Server: new clean Offer Lab API (standalone, avoids touching your existing route) ---
cat > server/routes/analysis_offerlab_clean.py <<'PY'
from fastapi import APIRouter, UploadFile, File, Form
from typing import List, Dict, Any
import os, io, re, tempfile, pdfplumber, fitz, math, json
from services.parsers.totals_any import extract_summary_from_pages
from services.parsers.extract_any import extract_any_bank_statement
from services.snapshot_metrics import compute_snapshot

router = APIRouter(prefix="/api/offerlab", tags=["offerlab"])

def _f(x):
    try: return float(x) if x is not None else 0.0
    except: return 0.0

def compute_offers(months: List[Dict[str,Any]], cadence: str="daily")->List[Dict[str,Any]]:
    if not months: return []
    dep_avg = sum(_f(r.get("total_deposits")) for r in months)/len(months)
    wires_avg = sum(_f(r.get("wire_credits")) for r in months)/len(months)
    eligible_inflow = max(0.0, dep_avg - wires_avg)
    mca_paid = sum(abs(_f(r.get("withdrawals_PFSINGLE_PT"))) for r in months)
    dep_sum = sum(_f(r.get("total_deposits")) for r in months)
    mca_load = (mca_paid/dep_sum) if dep_sum else 0.0
    holdback_cap = 0.08 if mca_load >= 0.90 else (0.10 if mca_load >= 0.80 else 0.12)

    business_days = 21
    weeks = 24
    term_days = weeks if cadence.lower()=="weekly" else 120
    daily_sales_proxy = eligible_inflow / business_days if business_days else 0.0
    weekly_sales_proxy = eligible_inflow / 4.2

    def remit_cap(cad):
        base = weekly_sales_proxy if cad=="weekly" else daily_sales_proxy
        return base * holdback_cap

    tiers = [
        {"name":"Tier A","factor":1.20,"advance_mult":0.60},
        {"name":"Tier B","factor":1.30,"advance_mult":0.80},
        {"name":"Tier C","factor":1.40,"advance_mult":1.00},
    ]
    offers=[]
    for t in tiers:
        adv = round(max(0.0, eligible_inflow*t["advance_mult"]), -2)
        pay = round(adv*t["factor"], -2)
        if cadence.lower()=="weekly":
            est = max(1, math.ceil(pay/max(1,weeks)))
            est = min(est, max(1, math.floor(remit_cap("weekly"))))
            offers.append({"id":t["name"].lower(),"name":t["name"],"factor":t["factor"],"advance":int(adv),
                           "payback":int(pay),"cadence":"Weekly","term_units":weeks,"est_remit":int(est),"holdback_cap":holdback_cap})
        else:
            est = max(1, math.ceil(pay/max(1,term_days)))
            est = min(est, max(1, math.floor(remit_cap("daily"))))
            offers.append({"id":t["name"].lower(),"name":t["name"],"factor":t["factor"],"advance":int(adv),
                           "payback":int(pay),"cadence":"Daily","term_units":term_days,"est_remit":int(est),"holdback_cap":holdback_cap})
    return [o for o in offers if o["advance"]>0 and o["est_remit"]>0]

def build_clean_scrub_pdf(pdf_paths: List[str], snapshot: Dict[str,Any]) -> bytes:
    doc_out = fitz.open()
    # 1-page summary
    page = doc_out.new_page(width=612, height=792)
    title = "Scrub Snapshot"
    pairs = [
        ("Avg Deposit Amount", f"${snapshot['avg_deposit_amount']:,}"),
        ("Other Advances",     f"${snapshot['other_advances']:,}"),
        ("Transfer Amount",    f"${snapshot['transfer_amount']:,}"),
        ("Misc Deduction",     f"${snapshot['misc_deduction']:,}"),
        ("Number of Deposits", f"{snapshot['number_of_deposits']:,}"),
        ("Negative Days",      f"{snapshot['negative_days']:,}"),
        ("Avg Daily Balance",  f"${snapshot['avg_daily_balance']:,}"),
        ("Avg Beginning Balance", f"${snapshot['avg_beginning_balance']:,}"),
        ("Avg Ending Balance", f"${snapshot['avg_ending_balance']:,}"),
    ]
    page.insert_textbox((36,36,576,90), title, fontsize=18, fontname="helv")
    y=110
    for i,(k,v) in enumerate(pairs):
        col = 36 if (i%2==0) else 320
        if i%2==0 and i>0: y += 36
        page.insert_textbox((col,y,col+250,y+16), k, fontsize=10, color=(0.3,0.35,0.4))
        page.insert_textbox((col,y+14,col+250,y+34), v, fontsize=14, color=(0,0,0))

    # Append scrubbed pages (white fill)
    for p in pdf_paths:
        try:
            d = fitz.open(p)
            for pg in d:
                text = pg.get_text("text")
                pats = [r"Routing\s*Number[:\s]*\d{7,13}", r"Account\s*Number[:\s]*\d{6,14}",
                        r"\b\d{3}-\d{2}-\d{4}\b", r"\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b",
                        r"\b\d{3}[-.\s]?\d{2,3}[-.\s]?\d{4}\b", r"\b(?:\d[ -]?){13,19}\b"]
                for pat in pats:
                    for m in re.finditer(pat, text, re.I):
                        for rect in pg.search_for(m.group(0)):
                            pg.add_redact_annot(rect, fill=(1,1,1))
                pg.apply_redactions()
            doc_out.insert_pdf(d)
            d.close()
        except Exception:
            pass
    return doc_out.tobytes(deflate=True)

@router.post("/analyze")
async def analyze(files: List[UploadFile]=File(...), remit: str=Form("daily")):
    import shutil, tempfile, json
    with tempfile.TemporaryDirectory() as tdir:
        paths=[]
        for f in files:
            p=os.path.join(tdir, f.filename or "statement.pdf")
            with open(p,"wb") as w: w.write(await f.read())
            paths.append(p)

        # parse each: deterministic totals + OCR/regex breakouts
        months=[]
        for p in paths:
            texts=[]
            with pdfplumber.open(p) as pdf:
                for pg in pdf.pages: texts.append(pg.extract_text() or "")
            det = extract_summary_from_pages(texts)
            row = extract_any_bank_statement(p)
            # prefer deterministic totals
            for k,v in det.items():
                if v not in (None,""): row[k]=v
            months.append(row)

        # snapshot + offers
        snapshot = compute_snapshot(months)
        offers = compute_offers(months, cadence=remit)

        # emit a clean combined PDF to /mnt/data so UI can link it
        pdf_bytes = build_clean_scrub_pdf(paths, snapshot)
        out_path = "/mnt/data/CLEAN_SCRUB_SNAPSHOT.pdf"
        with open(out_path,"wb") as w: w.write(pdf_bytes)

        return {
            "ok": True,
            "monthly_rows": months,
            "snapshot": snapshot,
            "offers": offers,
            "downloads": {"clean_scrub_pdf_path": "/mnt/data/CLEAN_SCRUB_SNAPSHOT.pdf"}
        }
PY

# --- 3. Server: hook the new router into FastAPI app (imports vary—handle both main.py patterns) ---
# Try common main file names:
MAIN_FILE=""
for f in server/main.py server/app.py; do
  if [ -f "$f" ]; then MAIN_FILE="$f"; break; fi
done
if [ -n "$MAIN_FILE" ]; then
  # add import & include_router if not present
  if ! grep -q "analysis_offerlab_clean" "$MAIN_FILE"; then
    sed -i "1 i\\from server.routes.analysis_offerlab_clean import router as offerlab_router" "$MAIN_FILE" || true
    sed -i "s/app = FastAPI([^)]*)/app = FastAPI()/" "$MAIN_FILE" 2>/dev/null || true
    # include router once
    if ! grep -q "include_router(offerlab_router)" "$MAIN_FILE"; then
      echo >> "$MAIN_FILE"
      echo "app.include_router(offerlab_router)" >> "$MAIN_FILE"
    fi
  fi
fi

# --- 4. Web UI: clean snapshot + offers page (new, so we don't touch your current page) ---
mkdir -p web/src/components/analysis web/src/pages

cat > web/src/components/analysis/ScrubSnapshotCard.tsx <<'TSX'
import React from 'react'
export type ScrubSnapshot = {
  avg_deposit_amount: number
  other_advances: number
  transfer_amount: number
  misc_deduction: number
  number_of_deposits: number
  negative_days: number
  avg_daily_balance: number
  avg_beginning_balance: number
  avg_ending_balance: number
}
const usd = (n:number)=> new Intl.NumberFormat('en-US',{style:'currency',currency:'USD'}).format(n||0)
export default function ScrubSnapshotCard({ snap, cleanPdfPath }: { snap: ScrubSnapshot|null, cleanPdfPath?: string|null }) {
  if (!snap) return null
  const Item = ({label, value}:{label:string; value:string}) => (
    <div className="bg-white border rounded-lg p-3">
      <div className="text-slate-500 text-xs">{label}</div>
      <div className="text-slate-900 font-semibold">{value}</div>
    </div>
  )
  return (
    <div className="bg-white rounded-2xl p-4 border">
      <div className="flex items-center justify-between">
        <div className="font-medium">Scrub Snapshot</div>
        {cleanPdfPath ? <a className="text-sm underline" href={cleanPdfPath} target="_blank" rel="noreferrer">Download Clean Scrub (PDF)</a> : null}
      </div>
      <div className="grid sm:grid-cols-2 lg:grid-cols-3 gap-3 mt-3 text-sm">
        <Item label="Avg Deposit Amount" value={usd(snap.avg_deposit_amount)} />
        <Item label="Other Advances" value={usd(snap.other_advances)} />
        <Item label="Transfer Amount" value={usd(snap.transfer_amount)} />
        <Item label="Misc Deduction" value={usd(snap.misc_deduction)} />
        <Item label="Number of Deposits" value={String(snap.number_of_deposits)} />
        <Item label="Negative Days" value={String(snap.negative_days)} />
        <Item label="Avg Daily Balance" value={usd(snap.avg_daily_balance)} />
        <Item label="Avg Beginning Balance" value={usd(snap.avg_beginning_balance)} />
        <Item label="Avg Ending Balance" value={usd(snap.avg_ending_balance)} />
      </div>
    </div>
  )
}
TSX

cat > web/src/components/analysis/OffersGrid.tsx <<'TSX'
import React from 'react'
type Offer = {
  id: string; name: string; factor: number; advance: number; payback: number;
  cadence: 'Daily'|'Weekly'; term_units: number; est_remit: number; holdback_cap: number; notes?: string
}
const usd = (n:number)=> new Intl.NumberFormat('en-US',{style:'currency',currency:'USD'}).format(n||0)
export default function OffersGrid({ offers, mcaLoad }: { offers: Offer[]; mcaLoad?: number }) {
  if (!offers?.length) return <div className="bg-white rounded-2xl p-6 border text-slate-600">No eligible offers.</div>
  return (
    <div className="bg-white rounded-2xl p-4 border">
      <div className="flex items-center justify-between mb-2">
        <div className="font-medium">MCA Offers</div>
        {typeof mcaLoad === 'number' && <div className="text-xs text-slate-500">Observed MCA Load: {Math.round(mcaLoad*100)}%</div>}
      </div>
      <div className="grid sm:grid-cols-2 lg:grid-cols-3 gap-3">
        {offers.map(o=>(
          <div key={o.id} className="rounded-xl border p-4 hover:shadow-sm transition">
            <div className="flex items-start justify-between">
              <div className="text-sm text-slate-500">{o.name}</div>
              <span className="text-[10px] px-2 py-0.5 rounded-full bg-slate-100 border">{o.cadence}</span>
            </div>
            <div className="mt-2 grid grid-cols-2 gap-2 text-sm">
              <div><div className="text-xs text-slate-500">Factor</div><div className="font-semibold">{o.factor.toFixed(2)}</div></div>
              <div><div className="text-xs text-slate-500">Advance</div><div className="font-semibold">{usd(o.advance)}</div></div>
              <div><div className="text-xs text-slate-500">Payback</div><div className="font-semibold">{usd(o.payback)}</div></div>
              <div><div className="text-xs text-slate-500">{o.cadence==='Daily'?'Term (days)':'Term (weeks)'}</div><div className="font-semibold">{o.term_units}</div></div>
              <div><div className="text-xs text-slate-500">Est. {o.cadence} Remit</div><div className="font-semibold">{usd(o.est_remit)}</div></div>
              <div><div className="text-xs text-slate-500">Holdback Cap</div><div className="font-semibold">{Math.round(o.holdback_cap*100)}%</div></div>
            </div>
            <div className="mt-3 flex gap-2">
              <button className="px-3 py-1.5 text-sm rounded-md bg-slate-900 text-white">Select</button>
              <button className="px-3 py-1.5 text-sm rounded-md border">Details</button>
            </div>
          </div>
        ))}
      </div>
    </div>
  )
}
TSX

cat > web/src/components/analysis/OfferInputsBar.tsx <<'TSX'
import React from 'react'
const usd = (n:number)=> new Intl.NumberFormat('en-US',{style:'currency',currency:'USD'}).format(n||0)
export default function OfferInputsBar({ depAvg, wiresAvg, eligibleInflow, holdbackCap, cadence }:{
  depAvg:number; wiresAvg:number; eligibleInflow:number; holdbackCap:number; cadence:'Daily'|'Weekly'
}) {
  return (
    <div className="bg-white rounded-2xl p-4 border">
      <div className="flex flex-wrap gap-4 items-center">
        <div><div className="text-xs text-slate-500">Avg Total Deposits</div><div className="font-semibold">{usd(depAvg)}</div></div>
        <div><div className="text-xs text-slate-500">Avg Wires (excluded)</div><div className="font-semibold">{usd(wiresAvg)}</div></div>
        <div><div className="text-xs text-slate-500">Eligible Inflow</div><div className="font-semibold">{usd(eligibleInflow)}</div></div>
        <div><div className="text-xs text-slate-500">Holdback Cap</div><div className="font-semibold">{Math.round(holdbackCap*100)}%</div></div>
        <div><div className="text-xs text-slate-500">Cadence</div><div className="font-semibold">{cadence}</div></div>
      </div>
    </div>
  )
}
TSX

# New clean page (keeps your existing OffersLab untouched)
cat > web/src/pages/OffersLabClean.tsx <<'TSX'
import React from 'react'
import ScrubSnapshotCard from '@/components/analysis/ScrubSnapshotCard'
import OfferInputsBar from '@/components/analysis/OfferInputsBar'
import OffersGrid from '@/components/analysis/OffersGrid'

const usd = (n:number)=> new Intl.NumberFormat('en-US',{style:'currency',currency:'USD'}).format(n||0)

export default function OffersLabClean(){
  const [files,setFiles] = React.useState<File[]>([])
  const [rows,setRows] = React.useState<any[]>([])
  const [snapshot,setSnapshot] = React.useState<any|null>(null)
  const [offers,setOffers] = React.useState<any[]>([])
  const [cleanPdf,setCleanPdf] = React.useState<string|null>(null)
  const [loading,setLoading] = React.useState(false)
  const [cadence,setCadence] = React.useState<'Daily'|'Weekly'>('Daily')

  const onUpload = async () => {
    if (!files.length) return
    setLoading(true)
    const fd = new FormData()
    files.forEach(f => fd.append('files', f))
    fd.append('remit', cadence.toLowerCase())
    const res = await fetch('/api/offerlab/analyze', { method:'POST', body: fd })
    const data = await res.json().catch(()=> ({}))
    setLoading(false)
    if (!res.ok || !data?.ok) { alert('Analysis failed'); return }
    setRows(data.monthly_rows||[])
    setSnapshot(data.snapshot||null)
    setOffers(data.offers||[])
    setCleanPdf(data.downloads?.clean_scrub_pdf_path || null)
  }

  const depAvg = React.useMemo(()=>{
    if (!rows.length) return 0
    return rows.reduce((a:any,r:any)=>a+Number(r.total_deposits||0),0)/rows.length
  },[rows])
  const wiresAvg = React.useMemo(()=>{
    if (!rows.length) return 0
    return rows.reduce((a:any,r:any)=>a+Number(r.wire_credits||0),0)/rows.length
  },[rows])
  const eligibleInflow = Math.max(0, depAvg - wiresAvg)
  const mcaLoad = React.useMemo(()=>{
    if (!rows.length) return undefined
    const mca = rows.reduce((a:any,r:any)=>a+Math.abs(Number(r.withdrawals_PFSINGLE_PT||0)),0)
    const dep = rows.reduce((a:any,r:any)=>a+Number(r.total_deposits||0),0)
    return dep ? (mca/dep) : undefined
  },[rows])
  const holdbackCap = (()=>{
    if (mcaLoad==null) return 0.1
    return mcaLoad >= 0.90 ? 0.08 : (mcaLoad >= 0.80 ? 0.10 : 0.12)
  })()

  return (
    <div className="max-w-6xl mx-auto p-4 space-y-4">
      <div className="bg-white border rounded-2xl p-4">
        <div className="flex flex-wrap items-center gap-3">
          <input type="file" multiple accept="application/pdf" onChange={e=> setFiles(Array.from(e.target.files||[]))} />
          <select value={cadence} onChange={e=> setCadence(e.target.value as any)} className="border rounded-md p-1 text-sm">
            <option>Daily</option><option>Weekly</option>
          </select>
          <button onClick={onUpload} disabled={loading} className="px-3 py-1.5 rounded-md bg-slate-900 text-white text-sm">
            {loading ? 'Analyzing…' : 'Analyze & Generate Offers'}
          </button>
          {cleanPdf && <a className="text-sm underline ml-auto" href={cleanPdf} target="_blank" rel="noreferrer">Download Clean Scrub (PDF)</a>}
        </div>
      </div>

      {snapshot && <ScrubSnapshotCard snap={snapshot} cleanPdfPath={cleanPdf} />}
      {rows.length > 0 && (
        <OfferInputsBar
          depAvg={depAvg}
          wiresAvg={wiresAvg}
          eligibleInflow={eligibleInflow}
          holdbackCap={holdbackCap}
          cadence={cadence}
        />
      )}
      <OffersGrid offers={offers||[]} mcaLoad={mcaLoad} />
    </div>
  )
}
TSX

# --- 5. Wire the new page into your router (tries common entry files; tweak if needed) ---
# If you have a central router file, we inject a route pointing to OffersLabClean.
ENTRY_FILE=""
for f in web/src/App.tsx web/src/main.tsx web/src/routes.tsx; do
  if [ -f "$f" ]; then ENTRY_FILE="$f"; break; fi
done
if [ -n "$ENTRY_FILE" ]; then
  # naive inject (React Router v6 style) – safe to run; wraps with lazy if not present
  if ! grep -q "OffersLabClean" "$ENTRY_FILE"; then
    sed -i "1 i\\import OffersLabClean from '@/pages/OffersLabClean'" "$ENTRY_FILE" 2>/dev/null || true
  fi
  # Try to append a route line if Routes element exists
  if grep -q "<Routes>" "$ENTRY_FILE"; then
    sed -i "s#</Routes>#  <Route path=\"/offers-lab-clean\" element={<OffersLabClean />} />\\
</Routes>#g" "$ENTRY_FILE" || true
  fi
fi

echo "✅ Done. Backend endpoint: POST /api/offerlab/analyze | Frontend page: /offers-lab-clean"

1) How to use (quick test)

Server-only test (no UI yet):

curl -s -X POST http://localhost:8000/api/offerlab/analyze \
  -F "remit=daily" \
  -F "files=@/mnt/data/68cda4ec8c6ec4_Months_Bank_Statement__July_25_us_bank_2579_.pdf" \
  -F "files=@/mnt/data/68cda4ec2b7fb4_Months_Bank_Statement__July_25_us_bank_2579_.pdf" \
  -F "files=@/mnt/data/68cda4ec6d82a4_Months_Bank_Statement__August_25_us_bank_2579_.pdf" | jq .


You should see ok: true, monthly_rows, snapshot, offers, and:

"downloads": { "clean_scrub_pdf_path": "/mnt/data/CLEAN_SCRUB_SNAPSHOT.pdf" }


Frontend page:

Open /offers-lab-clean

Upload PDFs → click Analyze & Generate Offers

You’ll get the Scrub Snapshot, Offer Inputs bar, and MCA Offers cards.

Download the Clean Scrub (PDF) from the top right.