Replit Implementation Brief — Offers Lab Dashboard

Goal: On the Offers Lab dashboard, show:

“Bank Statement Monthly Averages” KPIs + table (like the screenshot)

Decline rules panel

MCA offer suggestions (daily/weekly/holdback)

CSV Download button (optional)

All averages visible on the dashboard (not just CSV)

We already packaged the engine and a React panel. You can either download and drop the files or paste from below.

ZIP (ready-to-drop): bank_analysis_pkg.zip

0) Project assumptions

Frontend = React (Vite/CRA/Next).

Styling = Bootstrap.

You have a parser that returns parsed transactions in this shape:

type Transaction = {
  date: string;            // "YYYY-MM-DD"
  description: string;     // bank memo
  amount: number;          // positive number
  type: "credit"|"debit";  // credit=deposit, debit=withdrawal
  endingBalance?: number;  // end-of-day balance if available
  categoryHint?: string;   // optional
};


If a “get transactions” endpoint does not exist yet, add one quickly (examples at the end for Express and Flask).

1) Install Bootstrap (if not already)
npm i bootstrap


Add once in your client entry (pick one that exists):

// src/main.tsx OR src/App.tsx OR pages/_app.tsx (Next)
import "bootstrap/dist/css/bootstrap.min.css";

2) Add the analysis engine (frontend)

Create: src/analysis/bankAnalysis.ts
(Paste the full engine below — it computes monthly metrics, decline notes, recurring debits, and MCA offers.)

// src/analysis/bankAnalysis.ts
// === ANALYSIS ENGINE (framework-agnostic) ===
export type TxType = "credit" | "debit";
export interface Transaction {
  date: string;
  description: string;
  amount: number;
  type: TxType;
  endingBalance?: number | null;
  categoryHint?: string;
}
export interface MonthKey { year: number; month: number; }
export interface MonthlyMetrics {
  monthKey: MonthKey;
  totalDeposits: number;
  transferAmount: number;
  otherAdvances: number;
  miscDeductions: number;
  netDeposits: number;
  depositCount: number;
  negativeDays: number;
  averageDailyBalance: number;
  beginningBalance?: number;
  endingBalance?: number;
}
export interface RecurringPattern {
  name: string; totalAmount: number; count: number; avgAmount: number; firstSeen: string; lastSeen: string;
}
export interface AccountAnalysis {
  byMonth: MonthlyMetrics[];
  averages: MonthlyMetrics;
  recurringDebits: RecurringPattern[];
  monthsInRange: number;
  totalNetDeposits: number;
}
export interface DeclineFinding { code: string; message: string; severity: "info"|"warn"|"decline"; }
export interface DeclineRulesOptions {
  minimumRevenue3mo: number;
  constructionMin3mo?: number;
  negativeDayHardMax?: number;
  largeMoMDeltaPct?: number;
  poorDailyBalanceThreshold?: number;
  poorDailyBalanceHardMax?: number;
  remitToDepositDeclineOver?: number;
}
export interface Offer {
  tier: string; factor: number; advance: number; payback: number;
  method: "fixed-daily" | "fixed-weekly" | "holdback";
  dailyPayment?: number; weeklyPayment?: number; estTermDays?: number;
  holdbackPct?: number; estHoldbackDurationDays?: number;
}
export interface OfferOptions {
  factorTiers?: number[]; advanceMultiple?: number; excludeWires?: boolean;
  holdbackPercents?: number[]; fixedDaily?: boolean; fixedWeekly?: boolean;
  daysPerWeek?: number; termDays?: number; maxDebtServicePct?: number;
}

const RX = {
  transferCredit: /(transfer|xfer|internal)/i,
  otherAdvanceCredit: /(wire credit|funding|capital|advance)/i,
  miscDeduction: /(analysis fee|service fee|maintenance fee)/i,
  existingMCADebit: /(SETTLMT.*PFSINGLE PT|settlement.*pf|merchant.*funding|capital.*repay|loan.*payment)/i,
  cardPayments: /(AMEX|CHASE CREDIT CRD|EPAYMENT)/i,
  bankLoans: /(SBA EIDL|CADENCE BANK)/i,
  zelle: /zelle/i,
};
const sum = (a:number[]) => a.reduce((x,y)=>x+y,0);
const avg = (a:number[]) => a.length ? sum(a)/a.length : 0;
const ymKey = (d:Date) => ({year:d.getUTCFullYear(), month:d.getUTCMonth()+1});
const keyStr = (k:MonthKey) => `${k.year}-${String(k.month).padStart(2,"0")}`;
const norm = (s:string) => s.toUpperCase().replace(/\s+/g," ").trim();

function groupByMonth(txs: Transaction[]){
  const map = new Map<string, Transaction[]>();
  for (const t of txs) {
    const d = new Date(t.date); if (isNaN(d.getTime())) continue;
    const k = keyStr(ymKey(d)); if (!map.has(k)) map.set(k, []);
    map.get(k)!.push(t);
  }
  for (const [,arr] of map) arr.sort((a,b)=>new Date(a.date).getTime()-new Date(b.date).getTime());
  return map;
}
function classifyCredit(desc:string): "transfer"|"otherAdvance"|"regular" {
  const d = norm(desc);
  if (RX.transferCredit.test(d)) return "transfer";
  if (RX.otherAdvanceCredit.test(d)) return "otherAdvance";
  return "regular";
}
function classifyDebit(desc:string): "mca"|"miscFee"|"card"|"bankLoan"|"zelle"|"other" {
  const d = norm(desc);
  if (RX.existingMCADebit.test(d)) return "mca";
  if (RX.miscDeduction.test(d)) return "miscFee";
  if (RX.cardPayments.test(d)) return "card";
  if (RX.bankLoans.test(d)) return "bankLoan";
  if (RX.zelle.test(d)) return "zelle";
  return "other";
}

export function analyzeParsedStatements(transactions: Transaction[]): AccountAnalysis {
  const txs = transactions.slice().sort((a,b)=> new Date(a.date).getTime()-new Date(b.date).getTime());
  const byMonth = groupByMonth(txs);
  const monthly: MonthlyMetrics[] = [];

  for (const [k, arr] of Array.from(byMonth.entries()).sort()) {
    const [y,m] = k.split("-").map(Number);
    const credits = arr.filter(t=>t.type==="credit");
    const debits  = arr.filter(t=>t.type==="debit");

    const totalDeposits  = sum(credits.map(c=>+c.amount));
    const transferAmount = sum(credits.filter(c=>classifyCredit(c.description)==="transfer").map(c=>+c.amount));
    const otherAdvances  = sum(credits.filter(c=>classifyCredit(c.description)==="otherAdvance").map(c=>+c.amount));
    const miscDeductions = sum(debits.filter(d=>classifyDebit(d.description)==="miscFee").map(d=>+d.amount));
    const netDeposits    = Math.max(0, totalDeposits - transferAmount - otherAdvances);
    const depositCount   = credits.filter(c=>classifyCredit(c.description)==="regular").length;

    // daily ending balances if provided
    const byDay = new Map<string, Transaction[]>();
    for (const t of arr) {
      const day = t.date.slice(0,10);
      if (!byDay.has(day)) byDay.set(day, []);
      byDay.get(day)!.push(t);
    }
    const dailies:number[] = [];
    for (const [_, list] of Array.from(byDay.entries()).sort()){
      const eb = list.map(t=>t.endingBalance).filter(v=>typeof v==="number") as number[];
      if (eb.length) dailies.push(eb[eb.length-1]);
    }
    const averageDailyBalance = dailies.length ? avg(dailies) : 0;
    const negativeDays = dailies.filter(v=>v<0).length;

    const beginningBalance = arr.find(t=>t.endingBalance!=null)?.endingBalance ?? undefined;
    const endingBalance    = arr.slice().reverse().find(t=>t.endingBalance!=null)?.endingBalance ?? undefined;

    monthly.push({
      monthKey:{year:y,month:m},
      totalDeposits, transferAmount, otherAdvances, miscDeductions,
      netDeposits, depositCount, negativeDays, averageDailyBalance,
      beginningBalance, endingBalance
    });
  }

  const averages: MonthlyMetrics = {
    monthKey:{year:0,month:0},
    totalDeposits: avg(monthly.map(m=>m.totalDeposits)),
    transferAmount: avg(monthly.map(m=>m.transferAmount)),
    otherAdvances: avg(monthly.map(m=>m.otherAdvances)),
    miscDeductions: avg(monthly.map(m=>m.miscDeductions)),
    netDeposits: avg(monthly.map(m=>m.netDeposits)),
    depositCount: Math.round(avg(monthly.map(m=>m.depositCount))),
    negativeDays: Math.round(avg(monthly.map(m=>m.negativeDays))),
    averageDailyBalance: avg(monthly.map(m=>m.averageDailyBalance)),
  };

  // recurring debits
  const groups = new Map<string,{sum:number,count:number,first:string,last:string,amts:number[]}>();
  for (const d of txs.filter(t=>t.type==="debit")) {
    const key = norm(d.description).replace(/\d{4,}/g,"").replace(/\b(PMT|PAYMENT|PMT\.)\b/g,"PMT");
    if (!groups.has(key)) groups.set(key,{sum:0,count:0,first:d.date,last:d.date,amts:[]});
    const g = groups.get(key)!;
    g.sum += d.amount; g.count++; g.amts.push(d.amount);
    if (d.date<g.first) g.first=d.date; if (d.date>g.last) g.last=d.date;
  }
  const recurringDebits: RecurringPattern[] = [];
  for (const [name,g] of groups.entries()) if (g.count>=3)
    recurringDebits.push({name,totalAmount:g.sum,count:g.count,avgAmount:avg(g.amts),firstSeen:g.first,lastSeen:g.last});

  return { byMonth: monthly, averages, recurringDebits, monthsInRange: monthly.length, totalNetDeposits: sum(monthly.map(m=>m.netDeposits)) };
}

export function evaluateDeclines(a: AccountAnalysis, o: DeclineRulesOptions): DeclineFinding[] {
  const f: DeclineFinding[] = [];
  const last = a.byMonth.at(-1);
  const total3mo = a.byMonth.slice(-3).reduce((acc,m)=>acc+m.netDeposits,0);
  if (total3mo < o.minimumRevenue3mo) f.push({code:"MIN_REVENUE", severity:"decline", message:`Need ≥ $${o.minimumRevenue3mo.toLocaleString()} net deposits over 3 months. Have $${Math.round(total3mo).toLocaleString()}.`});
  if (o.negativeDayHardMax!=null && last && last.negativeDays>o.negativeDayHardMax) f.push({code:"NEG_DAYS", severity:"decline", message:`Most recent month has ${last.negativeDays} negative days; max ${o.negativeDayHardMax}.`});
  if (o.largeMoMDeltaPct!=null && a.byMonth.length>=2) {
    const [prev,cur] = a.byMonth.slice(-2);
    const delta = (cur.netDeposits - prev.netDeposits) / Math.max(1, prev.netDeposits);
    if (Math.abs(delta) > o.largeMoMDeltaPct) f.push({code:"MOM_SWING", severity:"decline", message:`MoM net deposit swing ${Math.round(delta*100)}% > ${Math.round(o.largeMoMDeltaPct*100)}%.`});
  }
  if (o.poorDailyBalanceThreshold!=null && o.poorDailyBalanceHardMax!=null && last)
    f.push({code:"POOR_BAL_DAYS_INFO", severity:"info", message:`Provide daily balances to compute < $${o.poorDailyBalanceThreshold} poor-day count exactly.`});
  return f;
}

export function suggestOffers(a: AccountAnalysis, opts: OfferOptions = {}): Offer[] {
  const factorTiers = opts.factorTiers ?? [1.20,1.30,1.40];
  const advanceMultiple = opts.advanceMultiple ?? 0.8;
  const holdbackPercents = opts.holdbackPercents ?? [0.08,0.10,0.12];
  const daysPerWeek = opts.daysPerWeek ?? 5;
  const termDaysTarget = opts.termDays ?? 120;
  const maxDSPct = opts.maxDebtServicePct ?? 0.25;

  const avgMonthlyNet = a.averages.netDeposits || (a.totalNetDeposits / Math.max(1,a.monthsInRange));
  const monthlyCapacity = avgMonthlyNet * maxDSPct;
  const dailyCapacity = monthlyCapacity / 22;
  const weeklyCapacity = monthlyCapacity / 4.33;
  const baseAdvance = avgMonthlyNet * advanceMultiple;

  const offers: Offer[] = [];
  for (let i=0;i<factorTiers.length;i++){
    const factor = factorTiers[i];
    const tier = i===0?"Conservative":i===1?"Standard":"Aggressive";
    const advance = Math.max(0, Math.round(baseAdvance));
    const payback = Math.round(advance*factor);

    const dailyPayment = Math.round(Math.min(dailyCapacity, payback/termDaysTarget));
    const weeklyPayment = Math.round(Math.min(weeklyCapacity, (payback/termDaysTarget)*daysPerWeek));

    offers.push({tier, factor, advance, payback, method:"fixed-daily", dailyPayment, estTermDays: Math.ceil(payback/Math.max(1,dailyPayment))});
    offers.push({tier, factor, advance, payback, method:"fixed-weekly", weeklyPayment, estTermDays: Math.ceil(payback/Math.max(1,weeklyPayment/daysPerWeek))});
    for (const hb of holdbackPercents){
      const holdbackDaily = (avgMonthlyNet/22)*hb;
      offers.push({tier, factor, advance, payback, method:"holdback", holdbackPct: hb, estHoldbackDurationDays: Math.ceil(payback/Math.max(1,holdbackDaily))});
    }
  }
  return offers;
}

export function fmt(n: number | undefined | null): string {
  if (n == null || isNaN(n as any)) return "-";
  return `$${n.toLocaleString(undefined,{maximumFractionDigits:2})}`;
}
export function toUiRows(a: AccountAnalysis){
  const rows = a.byMonth.map(m=>({
    month: `${m.monthKey.year}-${String(m.monthKey.month).padStart(2,"0")}`,
    totalDeposits: m.totalDeposits,
    transferAmt: m.transferAmount,
    otherAdvances: m.otherAdvances,
    miscDeductions: m.miscDeductions,
    netDeposits: m.netDeposits,
    numDeposits: m.depositCount,
    negDays: m.negativeDays,
    averageBal: m.averageDailyBalance,
    beginningBal: m.beginningBalance,
    endingBal: m.endingBalance,
  }));
  return { rows,
    averages: {
      totalDeposits: a.averages.totalDeposits,
      transferAmt: a.averages.transferAmount,
      otherAdvances: a.averages.otherAdvances,
      miscDeductions: a.averages.miscDeductions,
      netDeposits: a.averages.netDeposits,
      numDeposits: a.averages.depositCount,
      negDays: a.averages.negativeDays,
      averageBal: a.averages.averageDailyBalance,
    }
  };
}

3) Add the dashboard widget (frontend)

Create: src/components/OffersLabAnalysisCard.tsx

Fetches transactions (via /api/transactions?dealId=... or prop)

Runs analysis + rules + offers

Renders KPIs, table, decline rules, offers

Includes “Download CSV” button

// src/components/OffersLabAnalysisCard.tsx
import React, { useEffect, useMemo, useState } from "react";
import {
  analyzeParsedStatements, evaluateDeclines, suggestOffers,
  fmt, toUiRows, type Transaction, type AccountAnalysis
} from "../analysis/bankAnalysis";

type Props = {
  dealId?: string;                    // current deal/merchant id
  fetchUrl?: string;                  // optional override endpoint
  company?: { name?:string; dba?:string; industry?:string; startDate?:string; website?:string; owner?:string; creditScore?:number; ownership?:string; };
};

export default function OffersLabAnalysisCard({ dealId, fetchUrl, company }: Props) {
  const [txs, setTxs] = useState<Transaction[]|null>(null);
  const [error, setError] = useState<string|null>(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    const url = fetchUrl ?? `/api/transactions${dealId ? `?dealId=${encodeURIComponent(dealId)}` : ""}`;
    setLoading(true);
    fetch(url)
      .then(r => { if (!r.ok) throw new Error(`${r.status} ${r.statusText}`); return r.json(); })
      .then((data: Transaction[]) => setTxs(data || []))
      .catch(e => setError(e.message))
      .finally(() => setLoading(false));
  }, [dealId, fetchUrl]);

  const analysis: AccountAnalysis | null = useMemo(() => {
    if (!txs) return null;
    return analyzeParsedStatements(txs);
  }, [txs]);

  const declines = useMemo(() => {
    if (!analysis) return [];
    return evaluateDeclines(analysis, {
      minimumRevenue3mo: 20000,
      negativeDayHardMax: 5,
      largeMoMDeltaPct: 1.0,
      poorDailyBalanceThreshold: 100,
      poorDailyBalanceHardMax: 5,
      remitToDepositDeclineOver: 0.5,
    });
  }, [analysis]);

  const offers = useMemo(() => {
    if (!analysis) return [];
    return suggestOffers(analysis, {
      factorTiers: [1.20, 1.30, 1.40],
      advanceMultiple: 0.8,
      holdbackPercents: [0.08, 0.10, 0.12],
      fixedDaily: true,
      fixedWeekly: true,
      daysPerWeek: 5,
      termDays: 120,
      maxDebtServicePct: 0.25,
    });
  }, [analysis]);

  function groupOffers() {
    return offers.reduce((acc:any, o) => { (acc[o.tier] ||= []).push(o); return acc; }, {});
  }

  function downloadCSV() {
    if (!analysis) return;
    const ui = toUiRows(analysis);
    const header = ["Month","Total Deposits","Transfer Amt","Other Advances","Misc Deductions","Net Deposits","# of Deposits","Neg Days","Average Bal","Beginning Bal","Ending Bal"];
    const rows = ui.rows.map(r => ([
      r.month, r.totalDeposits, r.transferAmt, r.otherAdvances, r.miscDeductions,
      r.netDeposits, r.numDeposits, r.negDays, r.averageBal, r.beginningBal ?? "", r.endingBal ?? ""
    ]));
    const csv = [header, ...rows].map(line => line.join(",")).join("\n");
    const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `bank_statement_analysis_${Date.now()}.csv`;
    a.click();
    URL.revokeObjectURL(a.href);
  }

  if (loading) return <div className="card shadow-sm mb-3"><div className="card-body">Loading analysis…</div></div>;
  if (error)   return <div className="card shadow-sm mb-3"><div className="card-body text-danger">Error: {error}</div></div>;
  if (!analysis) return null;

  const ui = toUiRows(analysis);
  const tierMap = groupOffers();

  return (
    <>
      {/* Quick Information + Declines (left rail style) */}
      <div className="row g-3">
        <div className="col-lg-3">
          <div className="card shadow-sm mb-3">
            <div className="card-header bg-white fw-semibold">Quick Information</div>
            <div className="card-body">
              {company?.name && <p className="mb-1"><strong>Company Legal Name</strong><br/>{company.name}</p>}
              {company?.dba && <p className="mb-1"><strong>DBA</strong><br/>{company.dba}</p>}
              {company?.industry && <p className="mb-1"><strong>Industry Type</strong><br/>{company.industry}</p>}
              {company?.startDate && <p className="mb-1"><strong>Start date</strong><br/>{company.startDate}</p>}
              {company?.website && <p className="mb-1"><a href={company.website} target="_blank" rel="noreferrer">{company.website}</a></p>}
              <div className="d-flex gap-3">
                {company?.creditScore!=null && <div><small className="text-muted">Credit Score</small><div className="fs-5">{company.creditScore}</div></div>}
                {company?.ownership && <div><small className="text-muted">Ownership</small><div className="fs-5">{company.ownership}</div></div>}
              </div>
            </div>
          </div>

          <div className="card shadow-sm mb-3">
            <div className="card-header bg-white fw-semibold">Decline Rules</div>
            <div className="card-body">
              {!declines.length && <p className="text-muted mb-0">No hard declines detected.</p>}
              {declines.map(n => (
                <div key={n.code} className={`mb-2 p-2 rounded ${n.severity==="decline"?"bg-danger-subtle":"bg-warning-subtle"}`}>
                  <div className="fw-semibold">{n.code}</div>
                  <div>{n.message}</div>
                </div>
              ))}
            </div>
          </div>
        </div>

        <div className="col-lg-9">
          {/* Averages + Table + CSV */}
          <div className="card shadow-sm mb-3">
            <div className="card-header bg-white d-flex justify-content-between align-items-center">
              <div className="fw-semibold">Bank Statement Monthly Averages</div>
              <button onClick={downloadCSV} className="btn btn-sm btn-outline-secondary">Download CSV</button>
            </div>
            <div className="card-body">
              <div className="row text-center g-3">
                <KPI label="Avg Deposit Amount" value={fmt(ui.averages.totalDeposits)} />
                <KPI label="Avg Other Advances" value={fmt(ui.averages.otherAdvances)} />
                <KPI label="Avg Transfer Amount" value={fmt(ui.averages.transferAmt)} />
                <KPI label="Avg Misc Deduction" value={fmt(ui.averages.miscDeductions)} />
                <KPI label="Avg Net Deposit" value={fmt(ui.averages.netDeposits)} />
                <KPI label="Avg # Deposits" value={String(ui.averages.numDeposits)} />
                <KPI label="Avg Negative Days" value={String(ui.averages.negDays)} />
                <KPI label="Average Daily Balance" value={fmt(ui.averages.averageBal)} />
              </div>

              <div className="table-responsive mt-3">
                <table className="table table-sm align-middle">
                  <thead className="table-light">
                    <tr>
                      <th>Month</th>
                      <th className="text-end">Total Deposits</th>
                      <th className="text-end">Transfer Amt</th>
                      <th className="text-end">Other Advances</th>
                      <th className="text-end">Misc Deductions</th>
                      <th className="text-end">Net Deposits</th>
                      <th className="text-end"># of Deposits</th>
                      <th className="text-end">Neg Days</th>
                      <th className="text-end">Average Bal</th>
                      <th className="text-end">Beginning Bal</th>
                      <th className="text-end">Ending Bal</th>
                    </tr>
                  </thead>
                  <tbody>
                    {ui.rows.map(r => (
                      <tr key={r.month}>
                        <td>{r.month}</td>
                        <td className="text-end">{fmt(r.totalDeposits)}</td>
                        <td className="text-end">{fmt(r.transferAmt)}</td>
                        <td className="text-end">{fmt(r.otherAdvances)}</td>
                        <td className="text-end">{fmt(r.miscDeductions)}</td>
                        <td className="text-end">{fmt(r.netDeposits)}</td>
                        <td className="text-end">{r.numDeposits}</td>
                        <td className="text-end">{r.negDays}</td>
                        <td className="text-end">{fmt(r.averageBal)}</td>
                        <td className="text-end">{fmt(r.beginningBal)}</td>
                        <td className="text-end">{fmt(r.endingBal)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          </div>

          {/* Offers */}
          <div className="card shadow-sm mb-3">
            <div className="card-header bg-white fw-semibold">MCA Offer Suggestions</div>
            <div className="card-body">
              <div className="row g-3">
                {Object.entries(tierMap).map(([tier, list]) => (
                  <div className="col-md-4" key={tier}>
                    <div className="border rounded p-2 h-100">
                      <div className="fw-bold mb-2">{tier}</div>
                      {list.map((o:any,i:number) => (
                        <div key={i} className="mb-2 p-2 rounded bg-body-tertiary">
                          <div>Factor: <strong>{o.factor.toFixed(2)}</strong></div>
                          <div>Advance: <strong>{fmt(o.advance)}</strong></div>
                          <div>Payback: <strong>{fmt(o.payback)}</strong></div>
                          {o.method==="fixed-daily"  && <div>Daily Payment: <strong>{fmt(o.dailyPayment)}</strong> • Est Term: {o.estTermDays} days</div>}
                          {o.method==="fixed-weekly" && <div>Weekly Payment: <strong>{fmt(o.weeklyPayment)}</strong> • Est Term: {o.estTermDays} days</div>}
                          {o.method==="holdback"     && <div>Holdback: <strong>{Math.round((o.holdbackPct ?? 0)*100)}%</strong> • Est Duration: {o.estHoldbackDurationDays} days</div>}
                        </div>
                      ))}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>

        </div>
      </div>
    </>
  );
}

function KPI({label, value}:{label:string; value:string}){
  return (
    <div className="col-6 col-md-3">
      <div className="border rounded p-2 text-center">
        <div className="small text-muted">{label}</div>
        <div className="fs-5 fw-semibold">{value}</div>
      </div>
    </div>
  );
}

4) Render this on the Offers Lab dashboard

Find your Offers Lab dashboard container (e.g., src/pages/OffersLabDashboard.tsx or the dashboard route). Import and place the widget where you want it to appear:

import OffersLabAnalysisCard from "../components/OffersLabAnalysisCard";

export default function OffersLabDashboard(){
  // obtain current deal/merchant id from your router or context
  const dealId = new URLSearchParams(window.location.search).get("dealId") ?? undefined;

  return (
    <div className="container-fluid">
      {/* ...your other dashboard cards... */}
      <OffersLabAnalysisCard
        dealId={dealId}
        // fetchUrl="/api/transactions" // optionally override
        company={{
          name: "Medgluv Inc",
          dba: "Medgluv Inc",
          industry: "Miscellaneous Health Care and Social Assistance",
          startDate: "05/2001",
          website: "http://www.medgluv.com",
          owner: "Jerry Leong",
          creditScore: 630,
          ownership: "100%"
        }}
      />
    </div>
  );
}


If your dashboard uses a different file/route, do the same import there.

5) Backend: GET /api/transactions (choose one)
A) Node/Express (ts/js)
// server/routes/transactions.ts
import { Router } from "express";
const router = Router();

router.get("/transactions", async (req, res) => {
  const dealId = String(req.query.dealId || "");
  // TODO: load parsed transactions for this dealId from your DB or parser cache
  // Return an array<Transaction> as JSON:
  const txs = await loadTransactionsForDeal(dealId); // implement
  res.json(txs ?? []);
});

export default router;


And mount it:

// server/index.ts
import express from "express";
import transactionsRoute from "./routes/transactions";
const app = express();
app.use("/api", transactionsRoute);

B) Python/Flask
# server/routes_transactions.py
from flask import Blueprint, request, jsonify
bp = Blueprint("transactions", __name__)

@bp.get("/transactions")
def get_transactions():
    deal_id = request.args.get("dealId","")
    # TODO: fetch parsed transactions for this deal_id
    txs = load_transactions_for_deal(deal_id)  # implement
    return jsonify(txs or [])


Register:

# app.py
from routes_transactions import bp as transactions_bp
app.register_blueprint(transactions_bp, url_prefix="/api")

6) Hook to your parser

After you parse new PDFs (OpenAI/pdfplumber/MoneyThumb), store the resulting Transaction[] for the dealId and make your /api/transactions endpoint return them.

If you already have an endpoint that returns parsed transactions, just set fetchUrl on the card to that path.

7) Build & sanity check
npm run build
npm run dev   # verify dashboard renders KPIs, table, offers; try CSV

8) Commit
git add src/analysis/bankAnalysis.ts src/components/OffersLabAnalysisCard.tsx
git commit -m "feat(offers-lab): dashboard analysis widget + CSV download"
git push