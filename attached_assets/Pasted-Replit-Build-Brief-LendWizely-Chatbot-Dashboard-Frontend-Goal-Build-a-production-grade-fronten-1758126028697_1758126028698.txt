Replit Build Brief — LendWizely Chatbot Dashboard (Frontend)

Goal: Build a production-grade frontend (no backend code here) that connects to my existing FastAPI API. I need:

A chatbot simulator that talks like a human (persona/tone rules), for both new and existing clients.

An Admin Dashboard to define rules (conditions → actions) that the bot uses in live chats, plus previews.

Easy API setup: point to my backend with VITE_API_BASE and optional VITE_API_KEY.

Pages to test real flows: upload 3 PDFs → metrics, build offers with my factor/buy rate rules, background checks, e-sign, and connectors validation.

All rules/config saved to LocalStorage (and POSTable to my backend if /api/rules exists).

Stack

Vite + React + TypeScript + TailwindCSS

Zustand (global state) + React Router (SPA)

No server code; all API calls go to VITE_API_BASE

Persona/tone and rules are editable in the UI and saved in LocalStorage

Environment variables (Replit “Secrets”)

VITE_API_BASE (e.g. http://localhost:8080 or deployed FastAPI URL)

VITE_API_KEY (optional; used as Authorization: Bearer <key>)

App Structure (files Replit should create)
/src
  /pages
    Dashboard.tsx           # health, events, quick status
    ChatSimulator.tsx       # human-like bot; switch New vs Existing client
    RulesStudio.tsx         # rules builder + templates + persona
    OffersLab.tsx           # upload 3 PDFs -> /api/bank/parse -> /api/offers (with overrides)
    ConnectorsAdmin.tsx     # save + validate connectors (uses /api/connectors, /validate)
    BackgroundMonitor.tsx   # start job -> poll /api/background/jobs/{id}
    SignStudio.tsx          # send contract -> watch webhook status via /api/events
    Settings.tsx            # API base, API key, idempotency toggle
  /components
    ChatWindow.tsx
    MessageBubble.tsx
    ChatComposer.tsx
    RuleEditor.tsx          # visual condition/action builder
    RuleCard.tsx
    JsonEditor.tsx          # for advanced edits
    StatCard.tsx
  /state
    useAppStore.ts          # Zustand store: persona, rules, templates, api config
  /lib
    api.ts                  # fetch with base URL, API key, Idempotency-Key for POSTs
    rulesEngine.ts          # evaluate rules(context) -> actions
    templates.ts            # simple Mustache-style {{tokens}} renderer
    fixtures.ts             # demo clients (new/existing), demo metrics
  App.tsx
  main.tsx
  index.css

Pages & Features (what to implement)
1) Dashboard

Cards: API Health (GET /healthz), Events count (GET /api/events), Connectors list (GET /api/connectors)

Button “Seed demo data” → writes a few sample rules and templates into LocalStorage

2) Chat Simulator (most important)

Left: conversation (bubbles), Right: Client Profile panel with toggle New / Existing

Persona controls (from Rules Studio): voice (“friendly”, “professional”), reading level (6th-grade/8th-grade), emoji usage (low/med/high)

Composer at bottom: user types → rulesEngine runs with a context:

type ChatContext = {
  client: { status: 'new'|'existing', firstName, company, lastContactDays, consentOptedIn, email?, phone? }
  metrics?: Metrics // from /api/bank/parse or Plaid
  lastBotAction?: string
}


rulesEngine returns actions like:

sendMessage(templateId, vars) (render {{firstName}}, {{company}}, {{intakeLink}}…)

askForStatements (show upload card)

startPlaid (suggest connect; button opens Link if backend has /api/plaid/link-token)

generateOffers (calls /api/offers using overrides from Rules Studio)

scheduleFollowUp(days) (just simulate on UI)

Always append SMS compliance line to outreach previews: “Reply STOP to opt out.”

3) Rules Studio

Visual builder with Conditions and Actions

Conditions (AND/OR groups):

client.status is new|existing

client.lastContactDays >/< value

metrics.total_nsf_3m > value

metrics.avg_monthly_revenue >= value

consentOptedIn is true/false

Actions:

sendMessage(templateId)

setTone(persona) (affects chat style)

askForStatements

startPlaid

generateOffers

webhook(eventType, payload) (for future use; simulate only)

Templates Editor:

Simple tokens like {{firstName}}, {{company}}, {{intakeLink}}, {{avgMonthlyRevenue}}

Provide seed templates:

outreach_new: “Hey {{firstName}} — still looking for working capital? Quick approval: {{intakeLink}}. (Takes ~2 min)”

request_docs: “To tailor options, please upload your 3 most recent bank statements.”

plaid_prompt: “Prefer instant verification? Connect your bank securely to speed things up.”

offer_summary: “Based on your deposits/balances, here are a few options. We’ll keep daily payments comfortable.”

Overrides (MCA rules) panel:

Editable tiers: { factor, fee, term_days, buy_rate? }[]

Caps: payback_to_monthly_rev

Thresholds: max_nsf_3m, max_negative_days_3m

These are saved to LocalStorage and used in OffersLab; also sent as overrides to /api/offers

4) Offers Lab

Upload exactly 3 PDFs → POST /api/bank/parse → show Metrics

“Generate Offers”:

Option A (client-side preview): run a local copy of the deterministic math using current overrides and display cards

Option B (server): POST /api/offers with { ...metrics, overrides }

Show rationale (if server returns it) and expected_margin (if buy_rate set)

5) Connectors Admin

Save connector configs → POST /api/connectors (encrypted at rest on backend)

List → GET /api/connectors

Validate → POST /api/connectors/validate (live toggle)

Never show secrets; only masked keys unless dev

6) Background Monitor

Start job: POST /api/background/check (minimal person JSON) → returns {job_id}

Poll: GET /api/background/jobs/{job_id} until completed → show decision/notes

7) Sign Studio

Paste recipient name/email + base64 PDF → POST /api/sign/send → show envelope id

Poll /api/events to see sign.completed

8) Settings

Set API Base, API Key, Idempotency toggle. Persist to LocalStorage.

All POSTs include Idempotency-Key: <uuid> when toggle is on.

Rule Model (JSON your UI should save in LocalStorage)
type Rule = {
  id: string
  name: string
  priority: number
  enabled: boolean
  when: { op: 'AND'|'OR', conditions: Array<
    | { field: 'client.status', op: 'eq', value: 'new'|'existing' }
    | { field: 'client.lastContactDays', op: 'gt'|'lt'|'ge'|'le', value: number }
    | { field: 'metrics.total_nsf_3m'|'metrics.avg_monthly_revenue'|'metrics.total_days_negative_3m', op: 'gt'|'ge'|'lt'|'le', value: number }
    | { field: 'consentOptedIn', op: 'eq', value: boolean }
  >}
  then: Array<
    | { type: 'sendMessage', templateId: string }
    | { type: 'setTone', persona: 'friendly'|'professional'|'concise' }
    | { type: 'askForStatements' }
    | { type: 'startPlaid' }
    | { type: 'generateOffers' }
    | { type: 'scheduleFollowUp', days: number }
  >
}

Persona (saved to LocalStorage)
type Persona = {
  style: 'friendly'|'professional'|'concise'
  readingLevel: '6th'|'8th'|'10th'
  emoji: 'low'|'medium'|'high'
  disclaimers: { smsOptOut: boolean } // auto-append “Reply STOP to opt out.”
}

rulesEngine behavior

Input: context + rules[] sorted by priority

Evaluate first enabled rule whose condition matches; execute its then actions in order

sendMessage renders the chosen template via a simple token replacement (no arbitrary JS)

Tone/reading level/emoji tweak the language:

friendly → contractions, a light emoji if allowed

professional → no emoji, full words

concise → shorter sentences

Return a list of actions + a message string the bot should send

API Client behavior

All requests prefix with VITE_API_BASE

If VITE_API_KEY present, set header Authorization: Bearer <key>

For POST, if “Idempotency” is enabled, add header Idempotency-Key: <uuidv4>

Seed demo content the app should include

Two sample clients:

New: {status:'new', firstName:'Ava', company:'Maple Deli', lastContactDays:999, consentOptedIn:true}

Existing: {status:'existing', firstName:'Luis', company:'Bright Auto', lastContactDays:3, consentOptedIn:true}

Two sample rules:

R1 New Outreach (priority 10): if client.status == new → sendMessage(outreach_new), askForStatements, startPlaid

R2 Existing Followup (priority 20): if client.status == existing && lastContactDays > 7 → sendMessage(outreach_existing), generateOffers

Templates:

outreach_new and outreach_existing as described above

request_docs, plaid_prompt, offer_summary

Navigation

Top navbar with tabs: Dashboard · Chat · Rules · Offers · Connectors · Background · Sign · Settings

Acceptance Criteria (what Replit should verify)

App boots with npm run dev and shows the navbar

Settings: can set base URL and API key; persists across refresh

Chat: toggling New/Existing and pressing “Send” triggers rules; bot replies with human-like copy

Rules Studio: can create, reorder, enable/disable rules; edit templates and persona; preview message output

Offers Lab: upload exactly 3 PDFs → metrics render; pressing Generate calls server or uses local math with overrides

Connectors: can save a connector, list them, and run /validate (structure-only or live)

Background: can start a job and poll status → shows decision notes

Sign: can submit a test request and see envelope id; events page shows updates (if webhook is firing)

All POSTs include Authorization if API key is set; include Idempotency-Key when toggle is on

No secrets ever printed in the browser console

How to run (Replit)

Create a Node.js (Vite React + TS) repl.

Install dependencies: react, react-dom, react-router-dom, zustand, tailwindcss, postcss, autoprefixer, uuid.

Initialize Tailwind and include it in index.css.

Add the files above and implement the components/pages.

Create .env with:

VITE_API_BASE=https://YOUR-BACKEND-URL
VITE_API_KEY=replace_me   # optional


Start: npm run dev. Open the webview.

Tone requirement for the bot: Write like a capable funding manager: warm, direct, short sentences, minimal jargon, uses one emoji occasionally (friendly persona), and always includes compliant opt-out lines in outreach previews.

That’s it — please scaffold the full frontend per this brief.